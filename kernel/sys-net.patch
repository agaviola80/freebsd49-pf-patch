diff -Nur /usr/src/sys.orig/net/if_pflog.c /usr/src/sys/net/if_pflog.c
--- /usr/src/sys.orig/net/if_pflog.c	Thu Jan  1 08:00:00 1970
+++ /usr/src/sys/net/if_pflog.c	Thu Jul 10 13:44:17 2025
@@ -0,0 +1,192 @@
+/*	$OpenBSD: if_pflog.c,v 1.6 2002/06/30 13:04:36 itojun Exp $	*/
+/*
+ * The authors of this code are John Ioannidis (ji@tla.org),
+ * Angelos D. Keromytis (kermit@csd.uch.gr) and 
+ * Niels Provos (provos@physnet.uni-hamburg.de).
+ *
+ * This code was written by John Ioannidis for BSD/OS in Athens, Greece, 
+ * in November 1995.
+ *
+ * Ported to OpenBSD and NetBSD, with additional transforms, in December 1996,
+ * by Angelos D. Keromytis.
+ *
+ * Additional transforms and features in 1997 and 1998 by Angelos D. Keromytis
+ * and Niels Provos.
+ *
+ * Copyright (C) 1995, 1996, 1997, 1998 by John Ioannidis, Angelos D. Keromytis
+ * and Niels Provos.
+ * Copyright (c) 2001, Angelos D. Keromytis, Niels Provos.
+ *
+ * Permission to use, copy, and modify this software with or without fee
+ * is hereby granted, provided that this entire notice is included in
+ * all copies of any software which is or includes a copy or
+ * modification of this software. 
+ * You may use this code under the GNU public license if you so wish. Please
+ * contribute changes back to the authors under this freer than GPL license
+ * so that we may further the use of strong encryption without limitations to
+ * all.
+ *
+ * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
+ * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
+ * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
+ * PURPOSE.
+ */
+
+#ifndef NPFLOG
+#include "pflog.h"
+#endif
+#ifndef NBPF
+#include "bpf.h"
+#define NBPFILTER       NBPF
+#endif
+#include "opt_inet.h"
+#include "opt_inet6.h"
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/mbuf.h>
+#include <sys/socket.h>
+#include <sys/kernel.h>
+#include <sys/sockio.h>
+
+#include <net/if.h>
+#include <net/if_types.h>
+#include <net/route.h>
+#include <net/bpf.h>
+
+#ifdef  INET
+#include <netinet/in.h>
+#include <netinet/in_var.h>
+#include <netinet/in_systm.h>
+#include <netinet/ip.h>
+#endif
+
+#include <net/pfvar.h>
+#include <net/if_pflog.h>
+
+#ifdef	INET
+#include <netinet/in.h>
+#include <netinet/in_var.h>
+#endif
+
+#include <machine/in_cksum.h>
+
+#ifdef INET6
+#ifndef INET
+#include <netinet/in.h>
+#endif
+#include <netinet6/nd6.h>
+#endif /* INET6 */
+
+#define PFLOGMTU	(32768 + MHLEN + MLEN)
+
+#ifdef PFLOGDEBUG
+#define DPRINTF(x)    do { if (pflogdebug) printf x ; } while (0)
+#else
+#define DPRINTF(x)
+#endif
+
+struct	pflog_softc pflogif[NPFLOG];
+
+void	pflogattach(void *);
+PSEUDO_SET(pflogattach, if_pflog);
+
+int	pflogoutput(struct ifnet *, struct mbuf *, struct sockaddr *,
+	    struct rtentry *);
+int	pflogioctl(struct ifnet *, u_long, caddr_t);
+void	pflogrtrequest(int, struct rtentry *, struct sockaddr *);
+void	pflogstart(struct ifnet *);
+
+void
+pflogattach(void *pflog)
+{
+	struct ifnet *ifp;
+	int i;
+
+	bzero(pflogif, sizeof(pflogif)); 
+
+	for (i = 0; i < NPFLOG; i++) {  
+		ifp = &pflogif[i].sc_if; 
+		ifp->if_name = "pflog";
+		ifp->if_unit = i;
+		ifp->if_softc = &pflogif[i];
+		ifp->if_mtu = PFLOGMTU;
+		ifp->if_ioctl = pflogioctl;
+		ifp->if_output = pflogoutput;
+		ifp->if_start = pflogstart;
+		ifp->if_type = IFT_PFLOG;
+		ifp->if_snd.ifq_maxlen = ifqmaxlen;
+		ifp->if_hdrlen = PFLOG_HDRLEN;
+		if_attach(ifp);
+
+#if NBPFILTER > 0
+		bpfattach(ifp, DLT_PFLOG, PFLOG_HDRLEN);
+#endif
+
+	}
+}
+
+/*
+ * Start output on the pflog interface.
+ */
+void
+pflogstart(struct ifnet *ifp)
+{
+	struct mbuf *m;
+	int s;
+
+	for (;;) {
+		s = splnet();
+		IF_DROP(&ifp->if_snd);
+		IF_DEQUEUE(&ifp->if_snd, m);
+		splx(s);
+
+		if (m == NULL)
+			return;
+		else
+			m_freem(m);
+	}
+}
+
+int
+pflogoutput(struct ifnet *ifp, struct mbuf *m, struct sockaddr *dst,
+	struct rtentry *rt)
+{
+	m_freem(m);
+	return (0);
+}
+
+/* ARGSUSED */
+void
+pflogrtrequest(int cmd, struct rtentry *rt, struct sockaddr *sa)
+{
+	if (rt)
+		rt->rt_rmx.rmx_mtu = PFLOGMTU;
+}
+
+/* ARGSUSED */
+int
+pflogioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
+{
+	int error = 0;
+
+	switch (cmd) {
+	case SIOCSIFADDR:
+	case SIOCAIFADDR:
+	case SIOCSIFDSTADDR:
+	case SIOCSIFFLAGS:
+		if (ifp->if_flags & IFF_UP)
+			ifp->if_flags |= IFF_RUNNING;
+		else
+			ifp->if_flags &= ~IFF_RUNNING;
+		error = 0;
+		break;
+	default:
+		error = EINVAL;
+		break;
+	}
+
+	return (error);
+}
+
diff -Nur /usr/src/sys.orig/net/if_pflog.h /usr/src/sys/net/if_pflog.h
--- /usr/src/sys.orig/net/if_pflog.h	Thu Jan  1 08:00:00 1970
+++ /usr/src/sys/net/if_pflog.h	Sun Jul  6 23:46:46 2025
@@ -0,0 +1,46 @@
+/* $OpenBSD: if_pflog.h,v 1.6 2001/11/08 22:02:11 mickey Exp $ */
+/*
+ * Copyright 2001 Niels Provos <provos@citi.umich.edu>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _NET_IF_PFLOG_H_
+#define _NET_IF_PFLOG_H_
+
+struct pflog_softc {
+	struct ifnet	sc_if;  /* the interface */
+};
+
+struct pfloghdr {
+	u_int32_t af;
+	char ifname[IFNAMSIZ];
+	short rnr;
+	u_short reason;
+	u_short action;
+	u_short dir;
+};
+
+#define PFLOG_HDRLEN	sizeof(struct pfloghdr)
+
+extern struct pflog_softc pflogif[];
+#endif /* _NET_IF_PFLOG_H_ */
diff -Nur /usr/src/sys.orig/net/if_types.h /usr/src/sys/net/if_types.h
--- /usr/src/sys.orig/net/if_types.h	Tue Dec 24 07:02:21 2002
+++ /usr/src/sys/net/if_types.h	Fri Jul 11 17:35:33 2025
@@ -248,4 +248,5 @@
 #define	IFT_PVC		0xf1
 #define	IFT_FAITH	0xf2
 #define	IFT_STF		0xf3
+#define	IFT_PFLOG	0xf6
 #endif /* !_NET_IF_TYPES_H_ */
diff -Nur /usr/src/sys.orig/net/pf.c /usr/src/sys/net/pf.c
--- /usr/src/sys.orig/net/pf.c	Thu Jan  1 08:00:00 1970
+++ /usr/src/sys/net/pf.c	Fri Jul 11 16:12:03 2025
@@ -0,0 +1,4201 @@
+/*	$OpenBSD: pf.c,v 1.245 2002/09/27 17:57:53 henning Exp $ */
+
+/*
+ * Copyright (c) 2001 Daniel Hartmeier
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *    - Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    - Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Effort sponsored in part by the Defense Advanced Research Projects
+ * Agency (DARPA) and Air Force Research Laboratory, Air Force
+ * Materiel Command, USAF, under agreement number F30602-01-2-0537.
+ *
+ */
+
+#ifndef NPFLOG
+#include "pflog.h"
+#endif
+#ifndef NBPF 
+#include "bpf.h"
+#define NBPFILTER	NBPF
+#endif
+#include "opt_inet.h"
+#include "opt_inet6.h"
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/malloc.h>
+#include <sys/mbuf.h>
+#include <sys/filio.h>
+#include <sys/random.h>
+#include <sys/socket.h>
+#include <sys/socketvar.h>
+#include <sys/kernel.h>
+#include <sys/time.h>
+#include <sys/tree.h>
+#include <sys/ucred.h>
+#include <sys/sysctl.h>
+
+#include <net/if.h>
+#include <net/if_types.h>
+#include <net/bpf.h>
+#include <net/route.h>
+#include <net/if_pflog.h>
+
+#include <netinet/in.h>
+#include <netinet/in_var.h>
+#include <netinet/in_systm.h>
+#include <netinet/ip.h>
+#include <netinet/ip_var.h>
+#include <netinet/tcp.h>
+#include <netinet/tcp_fsm.h>
+#include <netinet/tcp_seq.h>
+#include <netinet/udp.h>
+#include <netinet/ip_icmp.h>
+#include <netinet/in_pcb.h>
+#include <netinet/tcp_timer.h>
+#include <netinet/tcp_var.h>
+#include <netinet/udp_var.h>
+
+#include <machine/in_cksum.h>
+
+#ifdef INET6
+#include <netinet/ip6.h>
+#include <netinet6/ip6_var.h>
+#include <netinet/icmp6.h>
+#include <netinet6/nd6.h>
+#include <netinet6/in6_pcb.h>
+#endif /* INET6 */
+
+#include <net/pfvar.h>
+
+#ifdef __FreeBSD__
+#undef KASSERT
+#define KASSERT(x)
+#define UID_MAX -1
+#define GID_MAX -1
+#define ip_mtudisc      0
+
+MALLOC_DEFINE(M_PF, "pf", "PF packet filter");
+ 
+#define MIN(a,b) (((a)<(b))?(a):(b))
+#define MAX(a,b) (((a)>(b))?(a):(b))
+#endif /* __FreeBSD__ */
+
+#define DPFPRINTF(n, x)	if (pf_status.debug >= (n)) printf x
+
+extern struct timeval time;
+struct pf_state_tree;
+
+/*
+ * Global variables
+ */
+struct pf_rulequeue	*pf_rules_active;
+struct pf_rulequeue	*pf_rules_inactive;
+struct pf_natqueue	*pf_nats_active;
+struct pf_natqueue	*pf_nats_inactive;
+struct pf_binatqueue	*pf_binats_active;
+struct pf_binatqueue	*pf_binats_inactive;
+struct pf_rdrqueue	*pf_rdrs_active;
+struct pf_rdrqueue	*pf_rdrs_inactive;
+struct pf_status	 pf_status;
+struct ifnet		*status_ifp;
+
+u_int32_t		 ticket_rules_active;
+u_int32_t		 ticket_rules_inactive;
+u_int32_t		 ticket_nats_active;
+u_int32_t		 ticket_nats_inactive;
+u_int32_t		 ticket_binats_active;
+u_int32_t		 ticket_binats_inactive;
+u_int32_t		 ticket_rdrs_active;
+u_int32_t		 ticket_rdrs_inactive;
+
+/* Timeouts */
+int			 pftm_tcp_first_packet = 120;	/* First TCP packet */
+int			 pftm_tcp_opening = 30;		/* No response yet */
+int			 pftm_tcp_established = 24*60*60;  /* established */
+int			 pftm_tcp_closing = 15 * 60;	/* Half closed */
+int			 pftm_tcp_fin_wait = 45;	/* Got both FINs */
+int			 pftm_tcp_closed = 90;		/* Got a RST */
+
+int			 pftm_udp_first_packet = 60;	/* First UDP packet */
+int			 pftm_udp_single = 30;		/* Unidirectional */
+int			 pftm_udp_multiple = 60;	/* Bidirectional */
+
+int			 pftm_icmp_first_packet = 20;	/* First ICMP packet */
+int			 pftm_icmp_error_reply = 10;	/* Got error response */
+
+int			 pftm_other_first_packet = 60;	/* First packet */
+int			 pftm_other_single = 30;	/* Unidirectional */
+int			 pftm_other_multiple = 60;	/* Bidirectional */
+
+int			 pftm_frag = 30;		/* Fragment expire */
+
+int			 pftm_interval = 10;		/* expire interval */
+struct callout		 pf_expire_to;			/* expire timeout */
+
+int			*pftm_timeouts[PFTM_MAX] = { &pftm_tcp_first_packet,
+				&pftm_tcp_opening, &pftm_tcp_established,
+				&pftm_tcp_closing, &pftm_tcp_fin_wait,
+				&pftm_tcp_closed, &pftm_udp_first_packet,
+				&pftm_udp_single, &pftm_udp_multiple,
+				&pftm_icmp_first_packet, &pftm_icmp_error_reply,
+				&pftm_other_first_packet, &pftm_other_single,
+				&pftm_other_multiple, &pftm_frag, &pftm_interval };
+
+pool_t			 pf_tree_pl, pf_rule_pl, pf_nat_pl, pf_sport_pl;
+pool_t			 pf_rdr_pl, pf_state_pl, pf_binat_pl, pf_addr_pl;
+void			 pf_dynaddr_update(void *);
+
+void			 pf_print_host(struct pf_addr *, u_int16_t, u_int8_t);
+void			 pf_print_state(struct pf_state *);
+void			 pf_print_flags(u_int8_t);
+
+u_int16_t		 pf_cksum_fixup(u_int16_t, u_int16_t, u_int16_t,
+			    u_int8_t);
+void			 pf_change_ap(struct pf_addr *, u_int16_t *,
+			    u_int16_t *, u_int16_t *, struct pf_addr *,
+			    u_int16_t, u_int8_t, int);
+void			 pf_change_a(void *, u_int16_t *, u_int32_t, u_int8_t);
+#ifdef INET6
+void			 pf_change_a6(struct pf_addr *, u_int16_t *,
+			    struct pf_addr *, u_int8_t);
+#endif /* INET6 */
+void			 pf_change_icmp(struct pf_addr *, u_int16_t *,
+			    struct pf_addr *, struct pf_addr *, u_int16_t,
+			    u_int16_t *, u_int16_t *, u_int16_t *,
+			    u_int16_t *, u_int8_t, int);
+void			 pf_send_reset(int, struct tcphdr *,
+			    struct pf_pdesc *, int, u_int8_t);
+void			 pf_send_icmp(struct mbuf *, u_int8_t, u_int8_t, int);
+u_int16_t		 pf_map_port_range(struct pf_rdr *, u_int16_t);
+struct pf_nat		*pf_get_nat(struct ifnet *, u_int8_t,
+			    struct pf_addr *, u_int16_t,
+			    struct pf_addr *, u_int16_t, int);
+struct pf_binat		*pf_get_binat(int, struct ifnet *, u_int8_t,
+			    struct pf_addr *, struct pf_addr *, int);
+struct pf_rdr		*pf_get_rdr(struct ifnet *, u_int8_t,
+			    struct pf_addr *, struct pf_addr *, u_int16_t, int);
+int			 pf_test_tcp(struct pf_rule **, int, struct ifnet *,
+			    struct mbuf *, int, int, void *, struct pf_pdesc *);
+int			 pf_test_udp(struct pf_rule **, int, struct ifnet *,
+			    struct mbuf *, int, int, void *, struct pf_pdesc *);
+int			 pf_test_icmp(struct pf_rule **, int, struct ifnet *,
+			    struct mbuf *, int, int, void *, struct pf_pdesc *);
+int			 pf_test_other(struct pf_rule **, int, struct ifnet *,
+			    struct mbuf *, void *, struct pf_pdesc *);
+int			 pf_test_fragment(struct pf_rule **, int, struct ifnet *,
+			    struct mbuf *, void *, struct pf_pdesc *);
+int			 pf_test_state_tcp(struct pf_state **, int,
+			    struct ifnet *, struct mbuf *, int, int,
+			    void *, struct pf_pdesc *);
+int			 pf_test_state_udp(struct pf_state **, int,
+			    struct ifnet *, struct mbuf *, int, int,
+			    void *, struct pf_pdesc *);
+int			 pf_test_state_icmp(struct pf_state **, int,
+			    struct ifnet *, struct mbuf *, int, int,
+			    void *, struct pf_pdesc *);
+int			 pf_test_state_other(struct pf_state **, int,
+			    struct ifnet *, struct pf_pdesc *);
+void			*pf_pull_hdr(struct mbuf *, int, void *, int,
+			    u_short *, u_short *, int);
+int			 pf_get_sport(u_int8_t, u_int8_t,
+			    struct pf_addr *, struct pf_addr *,
+			    u_int16_t, u_int16_t *, u_int16_t, u_int16_t);
+int			 pf_normalize_tcp(int, struct ifnet *, struct mbuf *,
+			    int, int, void *, struct pf_pdesc *);
+void			 pf_route(struct mbuf **, struct pf_rule *, int);
+void			 pf_route6(struct mbuf **, struct pf_rule *, int);
+int			 pf_socket_lookup(uid_t *, gid_t *, int, int, int,
+			     struct pf_pdesc *);
+
+#if NPFLOG > 0
+#define	PFLOG_PACKET(i,x,a,b,c,d,e) \
+	do { \
+		if (b == AF_INET) { \
+			HTONS(((struct ip *)x)->ip_len); \
+			HTONS(((struct ip *)x)->ip_off); \
+			pflog_packet(i,a,b,c,d,e); \
+			NTOHS(((struct ip *)x)->ip_len); \
+			NTOHS(((struct ip *)x)->ip_off); \
+		} else { \
+			pflog_packet(i,a,b,c,d,e); \
+		} \
+	} while (0)
+#else
+#define	PFLOG_PACKET(i,x,a,b,c,d,e)	((void)0)
+#endif
+
+#define	STATE_TRANSLATE(s) \
+	(s)->lan.addr.addr32[0] != (s)->gwy.addr.addr32[0] || \
+	((s)->af == AF_INET6 && \
+	((s)->lan.addr.addr32[1] != (s)->gwy.addr.addr32[1] || \
+	(s)->lan.addr.addr32[2] != (s)->gwy.addr.addr32[2] || \
+	(s)->lan.addr.addr32[3] != (s)->gwy.addr.addr32[3])) || \
+	(s)->lan.port != (s)->gwy.port
+
+#define TIMEOUT(r,i) \
+	(((r) && (r)->timeout[(i)]) ? (r)->timeout[(i)] : *pftm_timeouts[(i)])
+
+static int pf_state_compare(struct pf_tree_node *,
+			struct pf_tree_node *);
+
+struct pf_state_tree tree_lan_ext, tree_ext_gwy;
+RB_GENERATE(pf_state_tree, pf_tree_node, entry, pf_state_compare);
+
+struct pf_rulequeue		 pf_rules[2];
+struct pf_natqueue		 pf_nats[2];
+struct pf_binatqueue		 pf_binats[2];
+struct pf_rdrqueue		 pf_rdrs[2];
+
+static int
+pf_state_compare(struct pf_tree_node *a, struct pf_tree_node *b)
+{
+	int diff;
+
+	if ((diff = a->proto - b->proto) != 0)
+		return (diff);
+	if ((diff = a->af - b->af) != 0)
+		return (diff);
+	switch (a->af) {
+#ifdef INET
+	case AF_INET:
+		if (a->addr[0].addr32[0] > b->addr[0].addr32[0])
+			return (1);
+		if (a->addr[0].addr32[0] < b->addr[0].addr32[0])
+			return (-1);
+		if (a->addr[1].addr32[0] > b->addr[1].addr32[0])
+			return (1);
+		if (a->addr[1].addr32[0] < b->addr[1].addr32[0])
+			return (-1);
+		break;
+#endif /* INET */
+#ifdef INET6
+	case AF_INET6:
+		if (a->addr[0].addr32[0] > b->addr[0].addr32[0])
+			return (1);
+		if (a->addr[0].addr32[0] < b->addr[0].addr32[0])
+			return (-1);
+		if (a->addr[0].addr32[1] > b->addr[0].addr32[1])
+			return (1);
+		if (a->addr[0].addr32[1] < b->addr[0].addr32[1])
+			return (-1);
+		if (a->addr[0].addr32[2] > b->addr[0].addr32[2])
+			return (1);
+		if (a->addr[0].addr32[2] < b->addr[0].addr32[2])
+			return (-1);
+		if (a->addr[0].addr32[3] > b->addr[0].addr32[3])
+			return (1);
+		if (a->addr[0].addr32[3] < b->addr[0].addr32[3])
+			return (-1);
+		if (a->addr[1].addr32[0] > b->addr[1].addr32[0])
+			return (1);
+		if (a->addr[1].addr32[0] < b->addr[1].addr32[0])
+			return (-1);
+		if (a->addr[1].addr32[1] > b->addr[1].addr32[1])
+			return (1);
+		if (a->addr[1].addr32[1] < b->addr[1].addr32[1])
+			return (-1);
+		if (a->addr[1].addr32[2] > b->addr[1].addr32[2])
+			return (1);
+		if (a->addr[1].addr32[2] < b->addr[1].addr32[2])
+			return (-1);
+		if (a->addr[1].addr32[3] > b->addr[1].addr32[3])
+			return (1);
+		if (a->addr[1].addr32[3] < b->addr[1].addr32[3])
+			return (-1);
+		break;
+#endif /* INET6 */
+	}
+
+	if ((diff = a->port[0] - b->port[0]) != 0)
+		return (diff);
+	if ((diff = a->port[1] - b->port[1]) != 0)
+		return (diff);
+
+	return (0);
+}
+
+#ifdef INET6
+void
+pf_addrcpy(struct pf_addr *dst, struct pf_addr *src, u_int8_t af)
+{
+	switch(af) {
+#ifdef INET
+	case AF_INET:
+		dst->addr32[0] = src->addr32[0];
+		break;
+#endif /* INET */
+	case AF_INET6:
+		dst->addr32[0] = src->addr32[0];
+		dst->addr32[1] = src->addr32[1];
+		dst->addr32[2] = src->addr32[2];
+		dst->addr32[3] = src->addr32[3];
+		break;
+	}
+}
+#endif
+
+int
+pf_compare_rules(struct pf_rule *a, struct pf_rule *b)
+{
+	if (a->return_icmp != b->return_icmp ||
+	    a->action != b->action ||
+	    a->direction != b->direction ||
+	    a->log != b->log ||
+	    a->quick != b->quick ||
+	    a->keep_state != b->keep_state ||
+	    a->af != b->af ||
+	    a->proto != b->proto ||
+	    a->type != b->type ||
+	    a->code != b->code ||
+	    a->flags != b->flags ||
+	    a->flagset != b->flagset ||
+	    a->rule_flag != b->rule_flag ||
+	    a->min_ttl != b->min_ttl ||
+	    a->allow_opts != b->allow_opts)
+		return (1);
+	if (PF_ANEQ(&a->src.addr.addr, &b->src.addr.addr, a->af) ||
+	    PF_ANEQ(&a->src.mask, &b->src.mask, a->af) ||
+	    a->src.port[0] != b->src.port[0] ||
+	    a->src.port[1] != b->src.port[1] ||
+	    a->src.not != b->src.not ||
+	    a->src.port_op != b->src.port_op)
+		return (1);
+	if (PF_ANEQ(&a->dst.addr.addr, &b->dst.addr.addr, a->af) ||
+	    PF_ANEQ(&a->dst.mask, &b->dst.mask, a->af) ||
+	    a->dst.port[0] != b->dst.port[0] ||
+	    a->dst.port[1] != b->dst.port[1] ||
+	    a->dst.not != b->dst.not ||
+	    a->dst.port_op != b->dst.port_op)
+		return (1);
+	if (strcmp(a->ifname, b->ifname))
+		return (1);
+	if (a->ifnot != b->ifnot)
+		return (1);
+	return (0);
+}
+
+int
+pf_compare_nats(struct pf_nat *a, struct pf_nat *b)
+{
+	if (a->proto != b->proto ||
+	    a->af != b->af ||
+	    a->ifnot != b->ifnot ||
+	    a->no != b->no)
+		return (1);
+	if (PF_ANEQ(&a->src.addr.addr, &b->src.addr.addr, a->af) ||
+	    PF_ANEQ(&a->src.mask, &b->src.mask, a->af) ||
+	    a->src.port[0] != b->src.port[0] ||
+	    a->src.port[1] != b->src.port[1] ||
+	    a->src.not != b->src.not ||
+	    a->src.port_op != b->src.port_op)
+		return (1);
+	if (PF_ANEQ(&a->dst.addr.addr, &b->dst.addr.addr, a->af) ||
+	    PF_ANEQ(&a->dst.mask, &b->dst.mask, a->af) ||
+	    a->dst.port[0] != b->dst.port[0] ||
+	    a->dst.port[1] != b->dst.port[1] ||
+	    a->dst.not != b->dst.not ||
+	    a->dst.port_op != b->dst.port_op)
+		return (1);
+	if (PF_ANEQ(&a->raddr.addr, &b->raddr.addr, a->af))
+		return (1);
+	if (strcmp(a->ifname, b->ifname))
+		return (1);
+	return (0);
+}
+
+int
+pf_compare_binats(struct pf_binat *a, struct pf_binat *b)
+{
+	if (a->proto != b->proto ||
+	    a->dnot != b->dnot ||
+	    a->af != b->af ||
+	    a->no != b->no)
+		return (1);
+	if (PF_ANEQ(&a->saddr.addr, &b->saddr.addr, a->af))
+		return (1);
+	if (PF_ANEQ(&a->daddr.addr, &b->daddr.addr, a->af))
+		return (1);
+	if (PF_ANEQ(&a->dmask, &b->dmask, a->af))
+		return (1);
+	if (PF_ANEQ(&a->raddr.addr, &b->raddr.addr, a->af))
+		return (1);
+	if (strcmp(a->ifname, b->ifname))
+		return (1);
+	return (0);
+}
+
+int
+pf_compare_rdrs(struct pf_rdr *a, struct pf_rdr *b)
+{
+	if (a->dport != b->dport ||
+	    a->dport2 != b->dport2 ||
+	    a->rport != b->rport ||
+	    a->proto != b->proto ||
+	    a->af != b->af ||
+	    a->snot != b->snot ||
+	    a->dnot != b->dnot ||
+	    a->ifnot != b->ifnot ||
+	    a->opts != b->opts ||
+	    a->no != b->no)
+		return (1);
+	if (PF_ANEQ(&a->saddr.addr, &b->saddr.addr, a->af))
+		return (1);
+	if (PF_ANEQ(&a->smask, &b->smask, a->af))
+		return (1);
+	if (PF_ANEQ(&a->daddr.addr, &b->daddr.addr, a->af))
+		return (1);
+	if (PF_ANEQ(&a->dmask, &b->dmask, a->af))
+		return (1);
+	if (PF_ANEQ(&a->raddr.addr, &b->raddr.addr, a->af))
+		return (1);
+	if (strcmp(a->ifname, b->ifname))
+		return (1);
+	return (0);
+}
+
+int
+pflog_packet(struct ifnet *ifp, struct mbuf *m, int af, u_short dir,
+    u_short reason, struct pf_rule *rm)
+{
+#if NBPFILTER > 0
+	struct ifnet *ifn;
+	struct pfloghdr hdr;
+	struct mbuf m1;
+
+	if (ifp == NULL || m == NULL || rm == NULL)
+		return (-1);
+
+	hdr.af = htonl(af);
+	snprintf(hdr.ifname, sizeof(hdr.ifname), "%s%d", ifp->if_name,
+	    ifp->if_unit);
+	hdr.rnr = htons(rm->nr);
+	hdr.reason = htons(reason);
+	hdr.dir = htons(dir);
+	hdr.action = htons(rm->action);
+
+#ifdef INET
+	if (af == AF_INET && dir == PF_OUT) {
+		struct ip *ip;
+
+		ip = mtod(m, struct ip *);
+		ip->ip_sum = 0;
+		ip->ip_sum = in_cksum(m, ip->ip_hl << 2);
+	}
+#endif /* INET */
+
+	m1.m_next = m;
+	m1.m_len = PFLOG_HDRLEN;
+	m1.m_data = (char *) &hdr;
+
+	ifn = &(pflogif[0].sc_if);
+
+	if (ifn->if_bpf)
+		bpf_mtap(ifn, &m1);
+#endif
+
+	return (0);
+}
+
+struct pf_state *
+pf_find_state(struct pf_state_tree *tree, struct pf_tree_node *key)
+{
+	struct pf_tree_node *k;
+
+	pf_status.fcounters[FCNT_STATE_SEARCH]++;
+	k = RB_FIND(pf_state_tree, tree, key);
+	if (k)
+		return (k->state);
+	else
+		return (NULL);
+}
+
+int
+pf_insert_state(struct pf_state *state)
+{
+	struct pf_tree_node *keya, *keyb;
+
+	keya = pool_get(&pf_tree_pl, PR_NOWAIT);
+	if (keya == NULL)
+		return (-1);
+	keya->state = state;
+	keya->proto = state->proto;
+	keya->af = state->af;
+	PF_ACPY(&keya->addr[0], &state->lan.addr, state->af);
+	keya->port[0] = state->lan.port;
+	PF_ACPY(&keya->addr[1], &state->ext.addr, state->af);
+	keya->port[1] = state->ext.port;
+
+	/* Thou MUST NOT insert multiple duplicate keys */
+	if (RB_INSERT(pf_state_tree, &tree_lan_ext, keya) != NULL) {
+		if (pf_status.debug >= PF_DEBUG_MISC) {
+			printf("pf: state insert failed: tree_lan_ext");
+			printf(" lan: ");
+			pf_print_host(&state->lan.addr, state->lan.port,
+			    state->af);
+			printf(" gwy: ");
+			pf_print_host(&state->gwy.addr, state->gwy.port,
+			    state->af);
+			printf(" ext: ");
+			pf_print_host(&state->ext.addr, state->ext.port,
+			    state->af);
+			printf("\n");
+		}
+		pool_put(&pf_tree_pl, keya);
+		return (-1);
+	}
+
+	keyb = pool_get(&pf_tree_pl, PR_NOWAIT);
+	if (keyb == NULL) {
+		/* Need to pull out the other state */
+		RB_REMOVE(pf_state_tree, &tree_lan_ext, keya);
+		pool_put(&pf_tree_pl, keya);
+		return (-1);
+	}
+	keyb->state = state;
+	keyb->proto = state->proto;
+	keyb->af = state->af;
+	PF_ACPY(&keyb->addr[0], &state->ext.addr, state->af);
+	keyb->port[0] = state->ext.port;
+	PF_ACPY(&keyb->addr[1], &state->gwy.addr, state->af);
+	keyb->port[1] = state->gwy.port;
+
+	if (RB_INSERT(pf_state_tree, &tree_ext_gwy, keyb) != NULL) {
+		if (pf_status.debug >= PF_DEBUG_MISC) {
+			printf("pf: state insert failed: tree_ext_gwy");
+			printf(" lan: ");
+			pf_print_host(&state->lan.addr, state->lan.port,
+			    state->af);
+			printf(" gwy: ");
+			pf_print_host(&state->gwy.addr, state->gwy.port,
+			    state->af);
+			printf(" ext: ");
+			pf_print_host(&state->ext.addr, state->ext.port,
+			    state->af);
+			printf("\n");
+		}
+		RB_REMOVE(pf_state_tree, &tree_lan_ext, keya);
+		pool_put(&pf_tree_pl, keya);
+		pool_put(&pf_tree_pl, keyb);
+		return (-1);
+	}
+
+	pf_status.fcounters[FCNT_STATE_INSERT]++;
+	pf_status.states++;
+	return (0);
+}
+
+void
+pf_purge_timeout(void *arg)
+{
+	struct callout	*to = arg;
+	int s;
+
+	s = splnet();
+	pf_purge_expired_states();
+	pf_purge_expired_fragments();
+	splx(s);
+
+	callout_reset(to, pf_default_rule.timeout[PFTM_INTERVAL] * hz,
+	    pf_purge_timeout, to);
+}
+
+void
+pf_purge_expired_states(void)
+{
+	struct pf_tree_node *cur, *peer, *next;
+	struct pf_tree_node key;
+
+	for (cur = RB_MIN(pf_state_tree, &tree_ext_gwy); cur; cur = next) {
+		next = RB_NEXT(pf_state_tree, &tree_ext_gwy, cur);
+
+		if (cur->state->expire <= time.tv_sec) {
+			RB_REMOVE(pf_state_tree, &tree_ext_gwy, cur);
+
+			/* Need this key's peer (in the other tree) */
+			key.state = cur->state;
+			key.proto = cur->state->proto;
+			key.af = cur->state->af;
+			PF_ACPY(&key.addr[0], &cur->state->lan.addr,
+			    cur->state->af);
+			key.port[0] = cur->state->lan.port;
+			PF_ACPY(&key.addr[1], &cur->state->ext.addr,
+			    cur->state->af);
+			key.port[1] = cur->state->ext.port;
+
+			peer = RB_FIND(pf_state_tree, &tree_lan_ext, &key);
+			KASSERT(peer);
+			KASSERT(peer->state == cur->state);
+			RB_REMOVE(pf_state_tree, &tree_lan_ext, peer);
+
+			if (cur->state->rule.ptr != NULL)
+				cur->state->rule.ptr->states--;
+			pool_put(&pf_state_pl, cur->state);
+			pool_put(&pf_tree_pl, cur);
+			pool_put(&pf_tree_pl, peer);
+			pf_status.fcounters[FCNT_STATE_REMOVALS]++;
+			pf_status.states--;
+		}
+	}
+}
+
+int
+pf_dynaddr_setup(struct pf_addr_wrap *aw, u_int8_t af)
+{
+	if (aw->addr_dyn == NULL)
+		return (0);
+	aw->addr_dyn = pool_get(&pf_addr_pl, PR_NOWAIT);
+	if (aw->addr_dyn == NULL)
+		return (1);
+	bcopy(aw->addr.pfa.ifname, aw->addr_dyn->ifname,
+	    sizeof(aw->addr_dyn->ifname));
+	aw->addr_dyn->ifp = ifunit(aw->addr_dyn->ifname);
+	if (aw->addr_dyn->ifp == NULL) {
+		pool_put(&pf_addr_pl, aw->addr_dyn);
+		aw->addr_dyn = NULL;
+		return (1);
+	}
+	aw->addr_dyn->addr = &aw->addr;
+	aw->addr_dyn->af = af;
+	aw->addr_dyn->undefined = 1;
+	pf_dynaddr_update(aw->addr_dyn);
+	return (0);
+}
+
+void
+pf_dynaddr_update(void *p)
+{
+	struct pf_addr_dyn *ad = (struct pf_addr_dyn *)p;
+	struct ifaddr *ia;
+	int s, changed = 0;
+
+	if (ad == NULL || ad->ifp == NULL)
+		panic("pf_dynaddr_update");
+	s = splnet();
+	TAILQ_FOREACH(ia, &ad->ifp->if_addrlist, ifa_list)
+		if (ia->ifa_addr != NULL &&
+		    ia->ifa_addr->sa_family == ad->af) {
+			if (ad->af == AF_INET) {
+				struct in_addr *a, *b;
+
+				a = &ad->addr->v4;
+				b = &((struct sockaddr_in *)ia->ifa_addr)
+				    ->sin_addr;
+				if (ad->undefined ||
+				    memcmp(a, b, sizeof(*a))) {
+					bcopy(b, a, sizeof(*a));
+					changed = 1;
+				}
+			} else if (ad->af == AF_INET6) {
+				struct in6_addr *a, *b;
+
+				a = &ad->addr->v6;
+				b = &((struct sockaddr_in6 *)ia->ifa_addr)
+				    ->sin6_addr;
+				if (ad->undefined ||
+				    memcmp(a, b, sizeof(*a))) {
+					bcopy(b, a, sizeof(*a));
+					changed = 1;
+				}
+			}
+			if (changed)
+				ad->undefined = 0;
+			break;
+		}
+	if (ia == NULL)
+		ad->undefined = 1;
+	splx(s);
+}
+
+void
+pf_dynaddr_remove(struct pf_addr_wrap *aw)
+{
+	if (aw->addr_dyn == NULL)
+		return;
+	pool_put(&pf_addr_pl, aw->addr_dyn);
+	aw->addr_dyn = NULL;
+}
+
+void
+pf_dynaddr_copyout(struct pf_addr_wrap *aw)
+{
+	if (aw->addr_dyn == NULL)
+		return;
+	bcopy(aw->addr_dyn->ifname, aw->addr.pfa.ifname,
+	    sizeof(aw->addr.pfa.ifname));
+	aw->addr_dyn = (struct pf_addr_dyn *)1;
+}
+
+void
+pf_print_host(struct pf_addr *addr, u_int16_t p, u_int8_t af)
+{
+	switch(af) {
+#ifdef INET
+	case AF_INET: {
+		u_int32_t a = ntohl(addr->addr32[0]);
+		p = ntohs(p);
+		printf("%u.%u.%u.%u:%u", (a>>24)&255, (a>>16)&255,
+		    (a>>8)&255, a&255, p);
+		break;
+	}
+#endif /* INET */
+#ifdef INET6
+	case AF_INET6: {
+		u_int16_t b;
+		u_int8_t i, curstart = 255, curend = 0,
+		    maxstart = 0, maxend = 0;
+		for (i = 0; i < 8; i++) {
+			if (!addr->addr16[i]) {
+				if (curstart == 255)
+					curstart = i;
+				else
+					curend = i;
+			} else {
+				if (curstart) {
+					if ((curend - curstart) >
+					    (maxend - maxstart)) {
+						maxstart = curstart;
+						maxend = curend;
+						curstart = 255;
+					}
+				}
+			}
+		}
+		for (i = 0; i < 8; i++) {
+			if (i >= maxstart && i <= maxend) {
+				if (maxend != 7) {
+					if (i == maxstart)
+						printf(":");
+				} else {
+					if (i == maxend)
+						printf(":");
+				}
+			} else {
+				b = ntohs(addr->addr16[i]);
+				printf("%x", b);
+				if (i < 7)
+					printf(":");
+			}
+		}
+		p = ntohs(p);
+		printf("[%u]", p);
+		break;
+	}
+#endif /* INET6 */
+	}
+}
+
+void
+pf_print_state(struct pf_state *s)
+{
+	switch (s->proto) {
+	case IPPROTO_TCP:
+		printf("TCP ");
+		break;
+	case IPPROTO_UDP:
+		printf("UDP ");
+		break;
+	case IPPROTO_ICMP:
+		printf("ICMP ");
+		break;
+	case IPPROTO_ICMPV6:
+		printf("ICMPV6 ");
+		break;
+	default:
+		printf("%u ", s->proto);
+		break;
+	}
+	pf_print_host(&s->lan.addr, s->lan.port, s->af);
+	printf(" ");
+	pf_print_host(&s->gwy.addr, s->gwy.port, s->af);
+	printf(" ");
+	pf_print_host(&s->ext.addr, s->ext.port, s->af);
+	printf(" [lo=%u high=%u win=%u modulator=%u]", s->src.seqlo,
+	    s->src.seqhi, s->src.max_win, s->src.seqdiff);
+	printf(" [lo=%u high=%u win=%u modulator=%u]", s->dst.seqlo,
+	    s->dst.seqhi, s->dst.max_win, s->dst.seqdiff);
+	printf(" %u:%u", s->src.state, s->dst.state);
+}
+
+void
+pf_print_flags(u_int8_t f)
+{
+	if (f)
+		printf(" ");
+	if (f & TH_FIN)
+		printf("F");
+	if (f & TH_SYN)
+		printf("S");
+	if (f & TH_RST)
+		printf("R");
+	if (f & TH_PUSH)
+		printf("P");
+	if (f & TH_ACK)
+		printf("A");
+	if (f & TH_URG)
+		printf("U");
+	if (f & TH_ECE)
+		printf("E");
+	if (f & TH_CWR)
+		printf("W");
+}
+
+#define	PF_CALC_SKIP_STEP(i, c) \
+	do { \
+		if (a & 1 << i) { \
+			if (c) \
+				r->skip[i] = TAILQ_NEXT(s, entries); \
+			else \
+				a ^= 1 << i; \
+		} \
+	} while (0)
+
+void
+pf_calc_skip_steps(struct pf_rulequeue *rules)
+{
+	struct pf_rule *r, *s;
+	int a, i;
+
+	r = TAILQ_FIRST(rules);
+	while (r != NULL) {
+		a = 0;
+		for (i = 0; i < PF_SKIP_COUNT; ++i) {
+			a |= 1 << i;
+			r->skip[i] = TAILQ_NEXT(r, entries);
+		}
+		s = TAILQ_NEXT(r, entries);
+		while (a && s != NULL) {
+			PF_CALC_SKIP_STEP(PF_SKIP_ACTION,
+			    (s->action == PF_SCRUB && r->action == PF_SCRUB) ||
+			    (s->action != PF_SCRUB && r->action != PF_SCRUB));
+			PF_CALC_SKIP_STEP(PF_SKIP_IFP, 
+			    s->ifp == r->ifp && s->ifnot == r->ifnot);
+			PF_CALC_SKIP_STEP(PF_SKIP_DIR,
+			    s->direction == r->direction);
+			PF_CALC_SKIP_STEP(PF_SKIP_AF, s->af == r->af);
+			PF_CALC_SKIP_STEP(PF_SKIP_PROTO, s->proto == r->proto);
+			PF_CALC_SKIP_STEP(PF_SKIP_SRC_ADDR,
+			    s->src.addr.addr_dyn == NULL &&
+			    r->src.addr.addr_dyn == NULL &&
+			    PF_AEQ(&s->src.addr.addr, &r->src.addr.addr, r->af) &&
+			    PF_AEQ(&s->src.mask, &r->src.mask, r->af) &&
+			    s->src.not == r->src.not);
+			PF_CALC_SKIP_STEP(PF_SKIP_SRC_PORT,
+			    s->src.port[0] == r->src.port[0] &&
+			    s->src.port[1] == r->src.port[1] &&
+			    s->src.port_op == r->src.port_op);
+			PF_CALC_SKIP_STEP(PF_SKIP_DST_ADDR,
+			    s->dst.addr.addr_dyn == NULL &&
+			    r->dst.addr.addr_dyn == NULL &&
+			    PF_AEQ(&s->dst.addr.addr, &r->dst.addr.addr, r->af) &&
+			    PF_AEQ(&s->dst.mask, &r->dst.mask, r->af) &&
+			    s->dst.not == r->dst.not);
+			PF_CALC_SKIP_STEP(PF_SKIP_DST_PORT,
+			    s->dst.port[0] == r->dst.port[0] &&
+			    s->dst.port[1] == r->dst.port[1] &&
+			    s->dst.port_op == r->dst.port_op);
+			s = TAILQ_NEXT(s, entries);
+		}
+		r = TAILQ_NEXT(r, entries);
+	}
+}
+
+u_int16_t
+pf_cksum_fixup(u_int16_t cksum, u_int16_t old, u_int16_t new, u_int8_t udp)
+{
+	u_int32_t l;
+
+	if (udp && !cksum)
+		return (0x0000);
+	l = cksum + old - new;
+	l = (l >> 16) + (l & 65535);
+	l = l & 65535;
+	if (udp && !l)
+		return (0xFFFF);
+	return (l);
+}
+
+void
+pf_change_ap(struct pf_addr *a, u_int16_t *p, u_int16_t *ic, u_int16_t *pc,
+    struct pf_addr *an, u_int16_t pn, u_int8_t u, int af)
+{
+	struct pf_addr ao;
+	u_int16_t po = *p;
+
+	PF_ACPY(&ao, a, af);
+	PF_ACPY(a, an, af);
+
+	*p = pn;
+
+	switch (af) {
+#ifdef INET
+	case AF_INET:
+		*ic = pf_cksum_fixup(pf_cksum_fixup(*ic,
+		    ao.addr16[0], an->addr16[0], 0),
+		    ao.addr16[1], an->addr16[1], 0);
+		*p = pn;
+		*pc = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(*pc,
+		    ao.addr16[0], an->addr16[0], u),
+		    ao.addr16[1], an->addr16[1], u),
+		    po, pn, u);
+		break;
+#endif /* INET */
+#ifdef INET6
+	case AF_INET6:
+		*pc = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
+		    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
+		    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(*pc,
+		    ao.addr16[0], an->addr16[0], u),
+		    ao.addr16[1], an->addr16[1], u),
+		    ao.addr16[2], an->addr16[2], u),
+		    ao.addr16[3], an->addr16[3], u),
+		    ao.addr16[4], an->addr16[4], u),
+		    ao.addr16[5], an->addr16[5], u),
+		    ao.addr16[6], an->addr16[6], u),
+		    ao.addr16[7], an->addr16[7], u),
+		    po, pn, u);
+		break;
+#endif /* INET6 */
+	}
+}
+
+/* Changes a u_int32_t.  Uses a void * so there are no align restrictions */
+void
+pf_change_a(void *a, u_int16_t *c, u_int32_t an, u_int8_t u)
+{
+	u_int32_t ao;
+        
+	memcpy(&ao, a, sizeof(ao));
+	memcpy(a, &an, sizeof(u_int32_t));
+	*c = pf_cksum_fixup(pf_cksum_fixup(*c, ao / 65536, an / 65536, u),
+	    ao % 65536, an % 65536, u);
+}
+
+#ifdef INET6
+void
+pf_change_a6(struct pf_addr *a, u_int16_t *c, struct pf_addr *an, u_int8_t u)
+{
+	struct pf_addr ao;
+
+	PF_ACPY(&ao, a, AF_INET6);
+	PF_ACPY(a, an, AF_INET6);
+
+	*c = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
+	    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
+	    pf_cksum_fixup(pf_cksum_fixup(*c,
+	    ao.addr16[0], an->addr16[0], u),
+	    ao.addr16[1], an->addr16[1], u),
+	    ao.addr16[2], an->addr16[2], u),
+	    ao.addr16[3], an->addr16[3], u),
+	    ao.addr16[4], an->addr16[4], u),
+	    ao.addr16[5], an->addr16[5], u),
+	    ao.addr16[6], an->addr16[6], u),
+	    ao.addr16[7], an->addr16[7], u);
+}
+#endif /* INET6 */
+
+void
+pf_change_icmp(struct pf_addr *ia, u_int16_t *ip, struct pf_addr *oa,
+    struct pf_addr *na, u_int16_t np, u_int16_t *pc, u_int16_t *h2c,
+    u_int16_t *ic, u_int16_t *hc, u_int8_t u, int af)
+{
+        struct pf_addr  oia, ooa;
+
+        PF_ACPY(&oia, ia, af);
+        PF_ACPY(&ooa, oa, af);
+
+        /* Change inner protocol port, fix inner protocol checksum. */
+        if (ip != NULL) {
+                u_int16_t oip = *ip;
+                u_int32_t opc = 0;
+
+                if (pc != NULL)
+                        opc = *pc;
+                *ip = np;
+                if (pc != NULL)
+                        *pc = pf_cksum_fixup(*pc, oip, *ip, u);
+                *ic = pf_cksum_fixup(*ic, oip, *ip, 0);
+                if (pc != NULL)
+                        *ic = pf_cksum_fixup(*ic, opc, *pc, 0);
+        }
+        /* Change inner ip address, fix inner ip and icmp checksums. */
+        PF_ACPY(ia, na, af);
+        switch (af) {
+#ifdef INET
+        case AF_INET: {
+                u_int32_t        oh2c = *h2c;
+
+                *h2c = pf_cksum_fixup(pf_cksum_fixup(*h2c,
+                    oia.addr16[0], ia->addr16[0], 0),
+                    oia.addr16[1], ia->addr16[1], 0);
+                *ic = pf_cksum_fixup(pf_cksum_fixup(*ic,
+                    oia.addr16[0], ia->addr16[0], 0),
+                    oia.addr16[1], ia->addr16[1], 0);
+                *ic = pf_cksum_fixup(*ic, oh2c, *h2c, 0);
+                break;
+        }
+#endif /* INET */
+#ifdef INET6
+        case AF_INET6:
+                *ic = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
+                    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
+                    pf_cksum_fixup(pf_cksum_fixup(*ic,
+                    oia.addr16[0], ia->addr16[0], u),
+                    oia.addr16[1], ia->addr16[1], u),
+                    oia.addr16[2], ia->addr16[2], u),
+                    oia.addr16[3], ia->addr16[3], u),
+                    oia.addr16[4], ia->addr16[4], u),
+                    oia.addr16[5], ia->addr16[5], u),
+                    oia.addr16[6], ia->addr16[6], u),
+                    oia.addr16[7], ia->addr16[7], u);
+                break;
+#endif /* INET6 */
+        }
+        /* Change outer ip address, fix outer ip or icmpv6 checksum. */
+        PF_ACPY(oa, na, af);
+        switch (af) {
+#ifdef INET
+        case AF_INET:
+                *hc = pf_cksum_fixup(pf_cksum_fixup(*hc,
+                    ooa.addr16[0], oa->addr16[0], 0),
+                    ooa.addr16[1], oa->addr16[1], 0);
+                break;
+#endif /* INET */
+#ifdef INET6
+        case AF_INET6:
+                *ic = pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
+                    pf_cksum_fixup(pf_cksum_fixup(pf_cksum_fixup(
+                    pf_cksum_fixup(pf_cksum_fixup(*ic,
+                    ooa.addr16[0], oa->addr16[0], u),
+                    ooa.addr16[1], oa->addr16[1], u),
+                    ooa.addr16[2], oa->addr16[2], u),
+                    ooa.addr16[3], oa->addr16[3], u),
+                    ooa.addr16[4], oa->addr16[4], u),
+                    ooa.addr16[5], oa->addr16[5], u),
+                    ooa.addr16[6], oa->addr16[6], u),
+                    ooa.addr16[7], oa->addr16[7], u);
+                break;
+#endif /* INET6 */
+        }
+}
+
+void
+pf_send_reset(int off, struct tcphdr *th, struct pf_pdesc *pd, int af,
+    u_int8_t return_ttl)
+{
+	struct mbuf *m;
+	struct m_tag *mtag;
+	int len = 0;
+#ifdef INET
+	struct ip *h2 = NULL;
+#endif /* INET */
+#ifdef INET6
+	struct ip6_hdr *h2_6 = NULL;
+#endif /* INET6 */
+	struct tcphdr *th2 = NULL;
+
+	switch (af) {
+#ifdef INET
+	case AF_INET:
+		len = sizeof(struct ip) + sizeof(struct tcphdr);
+		break;
+#endif /* INET */
+#ifdef INET6
+	case AF_INET6:
+		len = sizeof(struct ip6_hdr) + sizeof(struct tcphdr);
+		break;
+#endif /* INET6 */
+	}
+
+	/* don't reply to RST packets */
+	if (th->th_flags & TH_RST)
+		return;
+
+	/* create outgoing mbuf */
+	mtag = m_tag_get(PACKET_TAG_PF_GENERATED, 0, M_NOWAIT);
+	if (mtag == NULL)
+		return;
+	m = m_gethdr(M_DONTWAIT, MT_HEADER);
+	if (m == NULL) {
+		m_tag_free(mtag);
+		return;
+	}
+	m_tag_prepend(m, mtag);
+	m->m_data += max_linkhdr;
+	m->m_pkthdr.len = m->m_len = len;
+	m->m_pkthdr.rcvif = NULL;
+	bzero(m->m_data, len);
+	switch (af) {
+#ifdef INET
+	case AF_INET:
+		h2 = mtod(m, struct ip *);
+
+		/* IP header fields included in the TCP checksum */
+		h2->ip_p = IPPROTO_TCP;
+		h2->ip_len = htons(sizeof(*th2));
+		h2->ip_src.s_addr = pd->dst->v4.s_addr;
+		h2->ip_dst.s_addr = pd->src->v4.s_addr;
+
+		th2 = (struct tcphdr *)((caddr_t)h2 + sizeof(struct ip));
+		break;
+#endif /* INET */
+#ifdef INET6
+	case AF_INET6:
+		h2_6 = mtod(m, struct ip6_hdr *);
+
+		/* IP header fields included in the TCP checksum */
+		h2_6->ip6_nxt = IPPROTO_TCP;
+		h2_6->ip6_plen = htons(sizeof(*th2));
+		memcpy(&h2_6->ip6_src, pd->dst, sizeof(struct in6_addr));
+		memcpy(&h2_6->ip6_dst, pd->src, sizeof(struct in6_addr));
+
+		th2 = (struct tcphdr *)((caddr_t)h2_6 + sizeof(struct ip6_hdr));
+		break;
+#endif /* INET6 */
+	}
+
+	/* TCP header */
+	th2->th_sport = th->th_dport;
+	th2->th_dport = th->th_sport;
+	if (th->th_flags & TH_ACK) {
+		th2->th_seq = th->th_ack;
+		th2->th_flags = TH_RST;
+	} else {
+		int tlen = pd->p_len;
+		if (th->th_flags & TH_SYN)
+			tlen++;
+		if (th->th_flags & TH_FIN)
+			tlen++;
+		th2->th_ack = htonl(ntohl(th->th_seq) + tlen);
+		th2->th_flags = TH_RST | TH_ACK;
+	}
+	th2->th_off = sizeof(*th2) >> 2;
+
+	switch (af) {
+#ifdef INET
+	case AF_INET:
+		/* TCP checksum */
+		th2->th_sum = in_cksum(m, len);
+
+		/* Finish the IP header */
+		h2->ip_v = 4;
+		h2->ip_hl = sizeof(*h2) >> 2;
+		if (!return_ttl)
+			return_ttl = ip_defttl;
+		h2->ip_ttl = return_ttl;
+		h2->ip_sum = 0;
+		h2->ip_len = len;
+		h2->ip_off = ip_mtudisc ? IP_DF : 0;
+		ip_output(m, (void *)NULL, (void *)NULL, 0, (void *)NULL,
+		  (void *)NULL);
+		break;
+#endif /* INET */
+#ifdef INET6
+	case AF_INET6:
+		/* TCP checksum */
+		th2->th_sum = in6_cksum(m, IPPROTO_TCP,
+		    sizeof(struct ip6_hdr), sizeof(*th));
+
+		h2_6->ip6_vfc |= IPV6_VERSION;
+		if (!return_ttl)
+			return_ttl = IPV6_DEFHLIM;
+		h2_6->ip6_hlim = return_ttl;
+
+		ip6_output(m, NULL, NULL, 0, NULL, NULL, NULL);
+#endif /* INET6 */
+	}
+}
+
+void
+pf_send_icmp(struct mbuf *m, u_int8_t type, u_int8_t code, int af)
+{
+	struct m_tag *mtag;
+	struct mbuf *m0;
+
+	mtag = m_tag_get(PACKET_TAG_PF_GENERATED, 0, M_NOWAIT);
+	if (mtag == NULL)
+		return;
+	m0 = m_copy(m, 0, M_COPYALL);
+	if (m0 == NULL) {
+		m_tag_free(mtag);
+		return;
+	}
+	m_tag_prepend(m0, mtag);
+	switch (af) {
+#ifdef INET
+	case AF_INET:
+		icmp_error(m0, type, code, 0, 0);
+		break;
+#endif /* INET */
+#ifdef INET6
+	case AF_INET6:
+		icmp6_error(m0, type, code, 0);
+		break;
+#endif /* INET6 */
+	}
+}
+
+/*
+ * Return 1 if the addresses a and b match (with mask m), otherwise return 0.
+ * If n is 0, they match if they are equal. If n is != 0, they match if they
+ * are different.
+ */
+int
+pf_match_addr(u_int8_t n, struct pf_addr *a, struct pf_addr *m,
+    struct pf_addr *b, int af)
+{
+	int match = 0;
+	switch (af) {
+#ifdef INET
+	case AF_INET:
+		if ((a->addr32[0] & m->addr32[0]) ==
+		    (b->addr32[0] & m->addr32[0]))
+			match++;
+		break;
+#endif /* INET */
+#ifdef INET6
+	case AF_INET6:
+		if (((a->addr32[0] & m->addr32[0]) ==
+		     (b->addr32[0] & m->addr32[0])) &&
+		    ((a->addr32[1] & m->addr32[1]) ==
+		     (b->addr32[1] & m->addr32[1])) &&
+		    ((a->addr32[2] & m->addr32[2]) ==
+		     (b->addr32[2] & m->addr32[2])) &&
+		    ((a->addr32[3] & m->addr32[3]) ==
+		     (b->addr32[3] & m->addr32[3])))
+			match++;
+		break;
+#endif /* INET6 */
+	}
+	if (match) {
+		if (n)
+			return (0);
+		else
+			return (1);
+	} else {
+		if (n)
+			return (1);
+		else
+			return (0);
+	}
+}
+
+int
+pf_match(u_int8_t op, u_int16_t a1, u_int16_t a2, u_int16_t p)
+{
+	switch (op) {
+	case PF_OP_IRG:
+		return ((p > a1) && (p < a2));
+	case PF_OP_XRG:
+		return ((p < a1) || (p > a2));
+	case PF_OP_EQ:
+		return (p == a1);
+	case PF_OP_NE:
+		return (p != a1);
+	case PF_OP_LT:
+		return (p < a1);
+	case PF_OP_LE:
+		return (p <= a1);
+	case PF_OP_GT:
+		return (p > a1);
+	case PF_OP_GE:
+		return (p >= a1);
+	}
+	return (0); /* never reached */
+}
+
+int
+pf_match_port(u_int8_t op, u_int16_t a1, u_int16_t a2, u_int16_t p)
+{
+	NTOHS(a1);
+	NTOHS(a2);
+	NTOHS(p);
+	return (pf_match(op, a1, a2, p));
+}
+
+int
+pf_match_uid(u_int8_t op, uid_t a1, uid_t a2, uid_t u)
+{
+	if (u == UID_MAX && op != PF_OP_EQ && op != PF_OP_NE)
+		return (0);
+	return (pf_match(op, a1, a2, u));
+}
+
+int
+pf_match_gid(u_int8_t op, gid_t a1, gid_t a2, gid_t g)
+{
+	if (g == GID_MAX && op != PF_OP_EQ && op != PF_OP_NE)
+		return (0);
+	return (pf_match(op, a1, a2, g));
+}
+
+int
+pf_get_sport(u_int8_t af, u_int8_t proto,
+    struct pf_addr *daddr, struct pf_addr *raddr,
+    u_int16_t dport, u_int16_t *port, u_int16_t low, u_int16_t high)
+{
+	struct pf_tree_node key;
+
+	int step;
+	u_int16_t cut;
+
+	if (!(proto == IPPROTO_TCP || proto == IPPROTO_UDP))
+		return (EINVAL);
+	if (low == 0 && high == 0) {
+		NTOHS(*port);
+		return (0);
+	}
+	if (low == high) {
+		*port = low;
+		return (0);
+	}
+
+	key.af = af;
+	key.proto = proto;
+	PF_ACPY(&key.addr[0], daddr, key.af);
+	PF_ACPY(&key.addr[1], raddr, key.af);
+	key.port[0] = dport;
+
+	/* port search; start random, step; similar 2 portloop in in_pcbbind */
+	if (low == high) {
+		key.port[1] = htons(low);
+		if (pf_find_state(&tree_ext_gwy, &key) == NULL) {
+			*port = low;
+			return (0);
+		}
+		return (1);
+	} else if (low < high) {
+		step = 1;
+		cut = arc4random() % (1 + high - low) + low;
+	} else {
+		step = -1;
+		cut = arc4random() % (1 + low - high) + high;
+	}
+
+	*port = cut - step;
+	do {
+		*port += step;
+		key.port[1] = htons(*port);
+		if (pf_find_state(&tree_ext_gwy, &key) == NULL)
+			return (0);
+	} while (*port != low && *port != high);
+
+	step = -step;
+	*port = cut;
+	do {
+		*port += step;
+		key.port[1] = htons(*port);
+		if (pf_find_state(&tree_ext_gwy, &key) == NULL)
+			return (0);
+	} while (*port != low && *port != high);
+
+	return (1);					/* none available */
+}
+
+struct pf_nat *
+pf_get_nat(struct ifnet *ifp, u_int8_t proto, struct pf_addr *saddr,
+    u_int16_t sport, struct pf_addr *daddr, u_int16_t dport, int af)
+{
+	struct pf_nat *n, *nm = NULL;
+
+	n = TAILQ_FIRST(pf_nats_active);
+	while (n && nm == NULL) {
+		if (((n->ifp == NULL) || (n->ifp == ifp && !n->ifnot) ||
+		    (n->ifp != ifp && n->ifnot)) &&
+		    (!n->proto || n->proto == proto) &&
+		    (!n->af || n->af == af) &&
+		    (n->src.addr.addr_dyn == NULL ||
+		    !n->src.addr.addr_dyn->undefined) &&
+		    PF_MATCHA(n->src.not, &n->src.addr.addr, &n->src.mask,
+		    saddr, af) &&
+		    (!n->src.port_op ||
+		    (proto != IPPROTO_TCP && proto != IPPROTO_UDP) ||
+		    pf_match_port(n->src.port_op, n->src.port[0],
+		    n->src.port[1], sport)) &&
+		    (n->dst.addr.addr_dyn == NULL ||
+		    !n->dst.addr.addr_dyn->undefined) &&
+		    PF_MATCHA(n->dst.not, &n->dst.addr.addr, &n->dst.mask,
+		    daddr, af) &&
+		    (!n->dst.port_op ||
+		    (proto != IPPROTO_TCP && proto != IPPROTO_UDP) ||
+		    pf_match_port(n->dst.port_op, n->dst.port[0],
+		    n->dst.port[1], dport)))
+			nm = n;
+		else
+			n = TAILQ_NEXT(n, entries);
+	}
+	if (nm && (nm->no || (nm->raddr.addr_dyn != NULL &&
+	    nm->raddr.addr_dyn->undefined)))
+		return (NULL);
+	return (nm);
+}
+
+struct pf_binat *
+pf_get_binat(int direction, struct ifnet *ifp, u_int8_t proto,
+    struct pf_addr *saddr, struct pf_addr *daddr, int af)
+{
+	struct pf_binat *b, *bm = NULL;
+	struct pf_addr fullmask;
+
+	memset(&fullmask, 0xff, sizeof(fullmask));
+
+	b = TAILQ_FIRST(pf_binats_active);
+	while (b && bm == NULL) {
+		if (direction == PF_OUT && b->ifp == ifp &&
+		    (!b->proto || b->proto == proto) &&
+		    (!b->af || b->af == af) &&
+		    (b->saddr.addr_dyn == NULL ||
+		    !b->saddr.addr_dyn->undefined) &&
+		    PF_MATCHA(0, &b->saddr.addr, &fullmask, saddr, af) &&
+		    (b->daddr.addr_dyn == NULL ||
+		    !b->daddr.addr_dyn->undefined) &&
+		    PF_MATCHA(b->dnot, &b->daddr.addr, &b->dmask, daddr, af))
+			bm = b;
+		else if (direction == PF_IN && b->ifp == ifp &&
+		    (!b->proto || b->proto == proto) &&
+		    (!b->af || b->af == af) &&
+		    (b->raddr.addr_dyn == NULL ||
+		    !b->raddr.addr_dyn->undefined) &&
+		    PF_MATCHA(0, &b->raddr.addr, &fullmask, saddr, af) &&
+		    (b->daddr.addr_dyn == NULL ||
+		    !b->daddr.addr_dyn->undefined) &&
+		    PF_MATCHA(b->dnot, &b->daddr.addr, &b->dmask, daddr, af))
+			bm = b;
+		else
+			b = TAILQ_NEXT(b, entries);
+	}
+	if (bm && bm->no)
+		return (NULL);
+	if (bm && direction == PF_OUT && bm->raddr.addr_dyn != NULL &&
+	    bm->raddr.addr_dyn->undefined)
+		return (NULL);
+	if (bm && direction == PF_IN && bm->saddr.addr_dyn != NULL &&
+	    bm->saddr.addr_dyn->undefined)
+		return (NULL);
+	return (bm);
+}
+
+struct pf_rdr *
+pf_get_rdr(struct ifnet *ifp, u_int8_t proto, struct pf_addr *saddr,
+    struct pf_addr *daddr, u_int16_t dport, int af)
+{
+	struct pf_rdr *r, *rm = NULL;
+
+	r = TAILQ_FIRST(pf_rdrs_active);
+	while (r && rm == NULL) {
+		if (((r->ifp == NULL) || (r->ifp == ifp && !r->ifnot) ||
+		    (r->ifp != ifp && r->ifnot)) &&
+		    (!r->proto || r->proto == proto) &&
+		    (!r->af || r->af == af) &&
+		    (r->saddr.addr_dyn == NULL ||
+		    !r->saddr.addr_dyn->undefined) &&
+		    PF_MATCHA(r->snot, &r->saddr.addr, &r->smask, saddr, af) &&
+		    (r->daddr.addr_dyn == NULL ||
+		    !r->daddr.addr_dyn->undefined) &&
+		    PF_MATCHA(r->dnot, &r->daddr.addr, &r->dmask, daddr, af) &&
+		    ((!r->dport2 && (!r->dport || dport == r->dport)) ||
+		    (r->dport2 && (ntohs(dport) >= ntohs(r->dport)) &&
+		    ntohs(dport) <= ntohs(r->dport2))))
+			rm = r;
+		else
+			r = TAILQ_NEXT(r, entries);
+	}
+	if (rm && (rm->no || (rm->raddr.addr_dyn != NULL &&
+	    rm->raddr.addr_dyn->undefined)))
+		return (NULL);
+	return (rm);
+}
+
+u_int16_t
+pf_map_port_range(struct pf_rdr *rdr, u_int16_t port)
+{
+	u_int32_t nport;
+
+	nport = ntohs(rdr->rport) - ntohs(rdr->dport) + ntohs(port);
+	/* wrap around if necessary */
+	if (nport > 65535)
+		nport -= 65535;
+	return (htons((u_int16_t)nport));
+}
+
+int
+pf_socket_lookup(uid_t *uid, gid_t *gid, int direction, int af, int proto,
+    struct pf_pdesc *pd)
+{
+	struct pf_addr *saddr, *daddr;
+	u_int16_t sport, dport;
+	struct inpcbinfo *tb;
+	struct inpcb *inp;
+
+	*uid = UID_MAX;
+	*gid = GID_MAX;
+	if (af != AF_INET)
+		return (0);
+	switch (proto) {
+	case IPPROTO_TCP:
+		sport = pd->hdr.tcp->th_sport;
+		dport = pd->hdr.tcp->th_dport;
+		tb = &tcbinfo;
+		break;
+	case IPPROTO_UDP:
+		sport = pd->hdr.udp->uh_sport;
+		dport = pd->hdr.udp->uh_dport;
+		tb = &udbinfo;
+		break;
+	default:
+		return (0);
+	}
+	if (direction == PF_IN) {
+		saddr = pd->src;
+		daddr = pd->dst;
+	} else {
+		u_int16_t p;
+
+		p = sport;
+		sport = dport;
+		dport = p;
+		saddr = pd->dst;
+		daddr = pd->src;
+	}
+	switch (pd->af) {
+#ifdef INET
+	case AF_INET:
+		inp = in_pcblookup_hash(tb, saddr->v4, sport, daddr->v4, dport,
+		    0, NULL);
+		if (inp == NULL) {
+			inp = in_pcblookup_hash(tb, saddr->v4, sport,
+			    daddr->v4, dport, INPLOOKUP_WILDCARD, NULL);
+			if (inp == NULL)
+				return (0);
+		}
+#endif /* INET */
+#ifdef INET6
+        case AF_INET6:
+		inp = in6_pcblookup_hash(tb, &saddr->v6, sport, &daddr->v6, dport,
+		    0, NULL);
+		if (inp == NULL) {
+			inp = in6_pcblookup_hash(tb, &saddr->v6, sport,
+			    &daddr->v6, dport, INPLOOKUP_WILDCARD, NULL);
+			if (inp == NULL)
+				return (0);
+		}
+		break;
+#endif /* INET6 */
+	default:
+		return (0);
+	}
+        if (inp->inp_socket->so_cred) {
+		*uid = inp->inp_socket->so_cred->cr_uid;
+		*gid = inp->inp_socket->so_cred->cr_groups[0];
+        }
+
+	return (1);
+}
+
+int
+pf_test_tcp(struct pf_rule **rm, int direction, struct ifnet *ifp,
+    struct mbuf *m, int ipoff, int off, void *h, struct pf_pdesc *pd)
+{
+	struct pf_nat *nat = NULL;
+	struct pf_binat *binat = NULL;
+	struct pf_rdr *rdr = NULL;
+	struct pf_addr *saddr = pd->src, *daddr = pd->dst, baddr;
+	struct tcphdr *th = pd->hdr.tcp;
+	u_int16_t bport = 0;
+	u_int16_t nport = 0;
+	u_int16_t af = pd->af;
+	int lookup = -1;
+	uid_t uid;
+	gid_t gid;
+	struct pf_rule *r;
+	u_short reason;
+	int rewrite = 0, error;
+
+	*rm = NULL;
+
+	if (direction == PF_OUT) {
+		/* check outgoing packet for BINAT */
+		if ((binat = pf_get_binat(PF_OUT, ifp, IPPROTO_TCP,
+		    saddr, daddr, af)) != NULL) {
+			PF_ACPY(&baddr, saddr, af);
+			bport = th->th_sport;
+			pf_change_ap(saddr, &th->th_sport, pd->ip_sum,
+			    &th->th_sum, &binat->raddr.addr, th->th_sport, 0, af);
+			rewrite++;
+		}
+		/* check outgoing packet for NAT */
+		else if ((nat = pf_get_nat(ifp, IPPROTO_TCP,
+		    saddr, th->th_sport, daddr, th->th_dport, af)) != NULL) {
+			bport = nport = th->th_sport;
+			error = pf_get_sport(af, IPPROTO_TCP, daddr,
+			    &nat->raddr.addr, th->th_dport, &nport,
+			    nat->proxy_port[0], nat->proxy_port[1]);
+			if (error) {
+				DPFPRINTF(PF_DEBUG_MISC,
+				    ("pf: NAT proxy port allocation "
+				    "(tcp %u-%u) failed\n",
+				    nat->proxy_port[0], nat->proxy_port[1]));
+				return (PF_DROP);
+			}
+			PF_ACPY(&baddr, saddr, af);
+			pf_change_ap(saddr, &th->th_sport, pd->ip_sum,
+			    &th->th_sum, &nat->raddr.addr, htons(nport),
+			    0, af);
+			rewrite++;
+		}
+	} else {
+		/* check incoming packet for RDR */
+		if ((rdr = pf_get_rdr(ifp, IPPROTO_TCP, saddr, daddr,
+		    th->th_dport, af)) != NULL) {
+			bport = th->th_dport;
+			if (rdr->opts & PF_RPORT_RANGE)
+				nport = pf_map_port_range(rdr, th->th_dport);
+			else if (rdr->rport)
+				nport = rdr->rport;
+			else
+				nport = bport;
+			PF_ACPY(&baddr, daddr, af);
+			pf_change_ap(daddr, &th->th_dport, pd->ip_sum,
+			    &th->th_sum, &rdr->raddr.addr, nport, 0, af);
+			rewrite++;
+		}
+		/* check incoming packet for BINAT */
+		else if ((binat = pf_get_binat(PF_IN, ifp, IPPROTO_TCP,
+		    daddr, saddr, af)) != NULL) {
+			PF_ACPY(&baddr, daddr, af);
+			bport = th->th_dport;
+			pf_change_ap(daddr, &th->th_dport, pd->ip_sum,
+			    &th->th_sum, &binat->saddr.addr, th->th_dport, 0, af);
+			rewrite++;
+		}
+	}
+
+	r = TAILQ_FIRST(pf_rules_active);
+	while (r != NULL) {
+		r->evaluations++;
+		if (r->action == PF_SCRUB)
+			r = r->skip[PF_SKIP_ACTION];
+		else if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
+		    (r->ifp == ifp && r->ifnot)))
+			r = r->skip[PF_SKIP_IFP];
+		else if (r->direction != direction)
+			r = r->skip[PF_SKIP_DIR];
+		else if (r->af && r->af != af)
+			r = r->skip[PF_SKIP_AF];
+		else if (r->proto && r->proto != IPPROTO_TCP)
+			r = r->skip[PF_SKIP_PROTO];
+		else if (r->src.noroute && pf_routable(saddr, af))
+			r = TAILQ_NEXT(r, entries);
+		else if (!r->src.noroute &&
+		    !PF_AZERO(&r->src.mask, af) && !PF_MATCHA(r->src.not,
+		    &r->src.addr.addr, &r->src.mask, saddr, af))
+			r = r->skip[PF_SKIP_SRC_ADDR];
+		else if (r->src.port_op && !pf_match_port(r->src.port_op,
+		    r->src.port[0], r->src.port[1], th->th_sport))
+			r = r->skip[PF_SKIP_SRC_PORT];
+		else if (r->dst.noroute && pf_routable(daddr, af))
+			r = TAILQ_NEXT(r, entries);
+		else if (!r->dst.noroute &&
+		    !PF_AZERO(&r->dst.mask, af) && !PF_MATCHA(r->dst.not,
+		    &r->dst.addr.addr, &r->dst.mask, daddr, af))
+			r = r->skip[PF_SKIP_DST_ADDR];
+		else if (r->dst.port_op && !pf_match_port(r->dst.port_op,
+		    r->dst.port[0], r->dst.port[1], th->th_dport))
+			r = r->skip[PF_SKIP_DST_PORT];
+		else if (r->rule_flag & PFRULE_FRAGMENT)
+			r = TAILQ_NEXT(r, entries);
+		else if ((r->flagset & th->th_flags) != r->flags)
+			r = TAILQ_NEXT(r, entries);
+		else if (r->uid.op && (lookup != -1 || (lookup =
+		    pf_socket_lookup(&uid, &gid, direction, af, IPPROTO_TCP, pd),
+		    1)) && !pf_match_uid(r->uid.op, r->uid.uid[0],
+		    r->uid.uid[1], uid))
+			r = TAILQ_NEXT(r, entries);
+		else if (r->gid.op && (lookup != -1 || (lookup =
+		    pf_socket_lookup(&uid, &gid, direction, af, IPPROTO_TCP, pd),
+		    1)) && !pf_match_gid(r->gid.op, r->gid.gid[0],
+		    r->gid.gid[1], gid))
+			r = TAILQ_NEXT(r, entries);
+		else {
+			*rm = r;
+			if ((*rm)->quick)
+				break;
+			r = TAILQ_NEXT(r, entries);
+		}
+	}
+
+	if (*rm != NULL) {
+		(*rm)->packets++;
+		(*rm)->bytes += pd->tot_len;
+		REASON_SET(&reason, PFRES_MATCH);
+
+		if ((*rm)->log) {
+			if (rewrite)
+				m_copyback(m, off, sizeof(*th), (caddr_t)th);
+			PFLOG_PACKET(ifp, h, m, af, direction, reason, *rm);
+		}
+
+		if (((*rm)->action == PF_DROP) &&
+		    (((*rm)->rule_flag & PFRULE_RETURNRST) ||
+		    (*rm)->return_icmp)) {
+			/* undo NAT/RST changes, if they have taken place */
+			if (nat != NULL ||
+			    (binat != NULL && direction == PF_OUT)) {
+				pf_change_ap(saddr, &th->th_sport, pd->ip_sum,
+				    &th->th_sum, &baddr, bport, 0, af);
+				rewrite++;
+			} else if (rdr != NULL ||
+			    (binat != NULL && direction == PF_IN)) {
+				pf_change_ap(daddr, &th->th_dport, pd->ip_sum,
+				    &th->th_sum, &baddr, bport, 0, af);
+				rewrite++;
+			}
+			if ((*rm)->rule_flag & PFRULE_RETURNRST)
+				pf_send_reset(off, th, pd, af,
+				    (*rm)->return_ttl);
+			else
+				pf_send_icmp(m, (*rm)->return_icmp >> 8,
+				    (*rm)->return_icmp & 255, af);
+		}
+
+		if ((*rm)->action == PF_DROP) 
+			return (PF_DROP);
+	}
+
+	if (((*rm != NULL) && (*rm)->keep_state) || nat != NULL ||
+	    binat != NULL || rdr != NULL) {
+		/* create new state */
+		u_int16_t len;
+		struct pf_state *s = NULL;
+
+		len = pd->tot_len - off - (th->th_off << 2);
+		if (*rm == NULL || !(*rm)->max_states ||
+		    (*rm)->states < (*rm)->max_states)
+			s = pool_get(&pf_state_pl, PR_NOWAIT);
+		if (s == NULL) {
+			REASON_SET(&reason, PFRES_MEMORY);
+			return (PF_DROP);
+		}
+		if (*rm != NULL)
+			(*rm)->states++;
+
+		s->rule.ptr = *rm;
+		s->allow_opts = *rm && (*rm)->allow_opts;
+		s->log = *rm && ((*rm)->log & 2);
+		s->proto = IPPROTO_TCP;
+		s->direction = direction;
+		s->af = af;
+		if (direction == PF_OUT) {
+			PF_ACPY(&s->gwy.addr, saddr, af);
+			s->gwy.port = th->th_sport;		/* sport */
+			PF_ACPY(&s->ext.addr, daddr, af);
+			s->ext.port = th->th_dport;
+			if (nat != NULL || binat != NULL) {
+				PF_ACPY(&s->lan.addr, &baddr, af);
+				s->lan.addr = baddr;
+				s->lan.port = bport;
+			} else {
+				PF_ACPY(&s->lan.addr, &s->gwy.addr, af);
+				s->lan.port = s->gwy.port;
+			}
+		} else {
+			PF_ACPY(&s->lan.addr, daddr, af);
+			s->lan.port = th->th_dport;
+			PF_ACPY(&s->ext.addr, saddr, af);
+			s->ext.port = th->th_sport;
+			if (binat != NULL ||rdr != NULL) {
+				PF_ACPY(&s->gwy.addr, &baddr, af);
+				s->gwy.port = bport;
+			} else {
+				PF_ACPY(&s->gwy.addr, &s->lan.addr, af);
+				s->gwy.port = s->lan.port;
+			}
+		}
+
+		s->src.seqlo = ntohl(th->th_seq);
+		s->src.seqhi = s->src.seqlo + len + 1;
+		if ((th->th_flags & (TH_SYN|TH_ACK)) == TH_SYN &&
+		    *rm != NULL && (*rm)->keep_state == PF_STATE_MODULATE) {
+			/* Generate sequence number modulator */
+			while ((s->src.seqdiff = arc4random()) == 0)
+				;
+			pf_change_a(&th->th_seq, &th->th_sum,
+			    htonl(s->src.seqlo + s->src.seqdiff), 0);
+			rewrite = 1;
+		} else
+			s->src.seqdiff = 0;
+		if (th->th_flags & TH_SYN)
+			s->src.seqhi++;
+		if (th->th_flags & TH_FIN)
+			s->src.seqhi++;
+		s->src.max_win = MAX(ntohs(th->th_win), 1);
+		s->dst.seqlo = 0;	/* Haven't seen these yet */
+		s->dst.seqhi = 1;
+		s->dst.max_win = 1;
+		s->dst.seqdiff = 0;	/* Defer random generation */
+		s->src.state = TCPS_SYN_SENT;
+		s->dst.state = TCPS_CLOSED;
+		s->creation = time.tv_sec;
+		s->expire = s->creation + TIMEOUT(*rm, PFTM_TCP_FIRST_PACKET);
+		s->packets = 1;
+		s->bytes = pd->tot_len;
+		if (pf_insert_state(s)) {
+			REASON_SET(&reason, PFRES_MEMORY);
+			pool_put(&pf_state_pl, s);
+			return (PF_DROP);
+		}
+	}
+
+	/* copy back packet headers if we performed NAT operations */
+	if (rewrite)
+		m_copyback(m, off, sizeof(*th), (caddr_t)th);
+
+	return (PF_PASS);
+}
+
+int
+pf_test_udp(struct pf_rule **rm, int direction, struct ifnet *ifp,
+    struct mbuf *m, int ipoff, int off, void *h, struct pf_pdesc *pd)
+{
+	struct pf_nat *nat = NULL;
+	struct pf_binat *binat = NULL;
+	struct pf_rdr *rdr = NULL;
+	struct pf_addr *saddr = pd->src, *daddr = pd->dst, baddr;
+	struct udphdr *uh = pd->hdr.udp;
+	u_int16_t bport = 0;
+	u_int16_t nport = 0;
+	u_int16_t af = pd->af;
+	int lookup = -1;
+	uid_t uid;
+	gid_t gid;
+	struct pf_rule *r;
+	u_short reason;
+	int rewrite = 0, error;
+
+	*rm = NULL;
+
+	if (direction == PF_OUT) {
+		/* check outgoing packet for BINAT */
+		if ((binat = pf_get_binat(PF_OUT, ifp, IPPROTO_UDP,
+		    saddr, daddr, af)) != NULL) {
+			PF_ACPY(&baddr, saddr, af);
+			bport = uh->uh_sport;
+			pf_change_ap(saddr, &uh->uh_sport, pd->ip_sum,
+			    &uh->uh_sum, &binat->raddr.addr, uh->uh_sport, 1, af);
+			rewrite++;
+		}
+		/* check outgoing packet for NAT */
+		else if ((nat = pf_get_nat(ifp, IPPROTO_UDP,
+		    saddr, uh->uh_sport, daddr, uh->uh_dport, af)) != NULL) {
+			bport = nport = uh->uh_sport;
+			error = pf_get_sport(af, IPPROTO_UDP, daddr,
+			    &nat->raddr.addr, uh->uh_dport, &nport,
+			    nat->proxy_port[0], nat->proxy_port[1]);
+			if (error) {
+				DPFPRINTF(PF_DEBUG_MISC,
+				    ("pf: NAT proxy port allocation "
+				    "(udp %u-%u) failed\n",
+				    nat->proxy_port[0], nat->proxy_port[1]));
+				return (PF_DROP);
+			}
+			PF_ACPY(&baddr, saddr, af);
+			pf_change_ap(saddr, &uh->uh_sport, pd->ip_sum,
+			    &uh->uh_sum, &nat->raddr.addr, htons(nport),
+			    1, af);
+			rewrite++;
+		}
+	} else {
+		/* check incoming packet for RDR */
+		if ((rdr = pf_get_rdr(ifp, IPPROTO_UDP, saddr, daddr,
+		    uh->uh_dport, af)) != NULL) {
+			bport = uh->uh_dport;
+			if (rdr->opts & PF_RPORT_RANGE)
+				nport = pf_map_port_range(rdr, uh->uh_dport);
+			else if (rdr->rport)
+				nport = rdr->rport;
+			else
+				nport = bport;
+
+			PF_ACPY(&baddr, daddr, af);
+			pf_change_ap(daddr, &uh->uh_dport, pd->ip_sum,
+			    &uh->uh_sum, &rdr->raddr.addr, nport, 1, af);
+			rewrite++;
+		}
+		/* check incoming packet for BINAT */
+		else if ((binat = pf_get_binat(PF_IN, ifp, IPPROTO_UDP,
+		    daddr, saddr, af)) != NULL) {
+			PF_ACPY(&baddr, daddr, af);
+			bport = uh->uh_dport;
+			pf_change_ap(daddr, &uh->uh_dport, pd->ip_sum,
+			    &uh->uh_sum, &binat->saddr.addr, uh->uh_dport, 1, af);
+			rewrite++;
+		}
+	}
+
+	r = TAILQ_FIRST(pf_rules_active);
+	while (r != NULL) {
+		r->evaluations++;
+		if (r->action == PF_SCRUB)
+			r = r->skip[PF_SKIP_ACTION];
+		else if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
+		    (r->ifp == ifp && r->ifnot)))
+			r = r->skip[PF_SKIP_IFP];
+		else if (r->direction != direction)
+			r = r->skip[PF_SKIP_DIR];
+		else if (r->af && r->af != af)
+			r = r->skip[PF_SKIP_AF];
+		else if (r->proto && r->proto != IPPROTO_UDP)
+			r = r->skip[PF_SKIP_PROTO];
+		else if (r->src.noroute && pf_routable(saddr, af))
+			r = TAILQ_NEXT(r, entries);
+		else if (!r->src.noroute &&
+		    !PF_AZERO(&r->src.mask, af) &&
+		    !PF_MATCHA(r->src.not, &r->src.addr.addr, &r->src.mask,
+		    saddr, af))
+			r = r->skip[PF_SKIP_SRC_ADDR];
+		else if (r->src.port_op && !pf_match_port(r->src.port_op,
+		    r->src.port[0], r->src.port[1], uh->uh_sport))
+			r = r->skip[PF_SKIP_SRC_PORT];
+		else if (r->dst.noroute && pf_routable(daddr, af))
+			r = TAILQ_NEXT(r, entries);
+		else if (!r->dst.noroute &&
+		    !PF_AZERO(&r->dst.mask, af) &&
+		    !PF_MATCHA(r->dst.not, &r->dst.addr.addr, &r->dst.mask,
+			daddr, af))
+			r = r->skip[PF_SKIP_DST_ADDR];
+		else if (r->dst.port_op && !pf_match_port(r->dst.port_op,
+		    r->dst.port[0], r->dst.port[1], uh->uh_dport))
+			r = r->skip[PF_SKIP_DST_PORT];
+		else if (r->rule_flag & PFRULE_FRAGMENT)
+			r = TAILQ_NEXT(r, entries);
+		else if (r->uid.op && (lookup != -1 || (lookup =
+		    pf_socket_lookup(&uid, &gid, direction, af, IPPROTO_UDP, pd),
+		    1)) && !pf_match_uid(r->uid.op, r->uid.uid[0],
+		    r->uid.uid[1], uid))
+			r = TAILQ_NEXT(r, entries);
+		else if (r->gid.op && (lookup != -1 || (lookup =
+		    pf_socket_lookup(&uid, &gid, direction, af, IPPROTO_UDP, pd),
+		    1)) && !pf_match_gid(r->gid.op, r->gid.gid[0],
+		    r->gid.gid[1], gid))
+			r = TAILQ_NEXT(r, entries);
+		else {
+			*rm = r;
+			if ((*rm)->quick)
+				break;
+			r = TAILQ_NEXT(r, entries);
+		}
+	}
+
+	if (*rm != NULL) {
+		(*rm)->packets++;
+		(*rm)->bytes += pd->tot_len;
+		REASON_SET(&reason, PFRES_MATCH);
+
+		if ((*rm)->log) {
+			if (rewrite)
+				m_copyback(m, off, sizeof(*uh), (caddr_t)uh);
+			PFLOG_PACKET(ifp, h, m, af, direction, reason, *rm);
+		}
+
+		if (((*rm)->action == PF_DROP) && (*rm)->return_icmp) {
+			/* undo NAT/RST changes, if they have taken place */
+			if (nat != NULL ||
+			    (binat != NULL && direction == PF_OUT)) {
+				pf_change_ap(saddr, &uh->uh_sport, pd->ip_sum,
+				    &uh->uh_sum, &baddr, bport, 1, af);
+				rewrite++;
+			} else if (rdr != NULL ||
+			    (binat != NULL && direction == PF_IN)) {
+				pf_change_ap(daddr, &uh->uh_dport, pd->ip_sum,
+				    &uh->uh_sum, &baddr, bport, 1, af);
+				rewrite++;
+			}
+			pf_send_icmp(m, (*rm)->return_icmp >> 8,
+			    (*rm)->return_icmp & 255, af);
+		}
+
+		if ((*rm)->action == PF_DROP) 
+			return (PF_DROP);
+	}
+
+	if ((*rm != NULL && (*rm)->keep_state) || nat != NULL ||
+	    binat != NULL || rdr != NULL) {
+		/* create new state */
+		struct pf_state *s = NULL;
+
+		if (*rm == NULL || !(*rm)->max_states ||
+		    (*rm)->states < (*rm)->max_states)
+			s = pool_get(&pf_state_pl, PR_NOWAIT);
+		if (s == NULL)
+			return (PF_DROP);
+		if (*rm != NULL)
+			(*rm)->states++;
+
+		s->rule.ptr = *rm;
+		s->allow_opts = *rm && (*rm)->allow_opts;
+		s->log = *rm && ((*rm)->log & 2);
+		s->proto = IPPROTO_UDP;
+		s->direction = direction;
+		s->af = af;
+		if (direction == PF_OUT) {
+			PF_ACPY(&s->gwy.addr, saddr, af);
+			s->gwy.port = uh->uh_sport;
+			PF_ACPY(&s->ext.addr, daddr, af);
+			s->ext.port = uh->uh_dport;
+			if (nat != NULL || binat != NULL) {
+				PF_ACPY(&s->lan.addr, &baddr, af);
+				s->lan.port = bport;
+			} else {
+				PF_ACPY(&s->lan.addr, &s->gwy.addr, af);
+				s->lan.port = s->gwy.port;
+			}
+		} else {
+			PF_ACPY(&s->lan.addr, daddr, af);
+			s->lan.port = uh->uh_dport;
+			PF_ACPY(&s->ext.addr, saddr, af);
+			s->ext.port = uh->uh_sport;
+			if (binat != NULL || rdr != NULL) {
+				PF_ACPY(&s->gwy.addr, &baddr, af);
+				s->gwy.port = bport;
+			} else {
+				PF_ACPY(&s->gwy.addr, &s->lan.addr, af);
+				s->gwy.port = s->lan.port;
+			}
+		}
+		s->src.seqlo = 0;
+		s->src.seqhi = 0;
+		s->src.seqdiff = 0;
+		s->src.max_win = 0;
+		s->src.state = PFUDPS_SINGLE;
+		s->dst.seqlo = 0;
+		s->dst.seqhi = 0;
+		s->dst.seqdiff = 0;
+		s->dst.max_win = 0;
+		s->dst.state = PFUDPS_NO_TRAFFIC;
+		s->creation = time.tv_sec;
+		s->expire = s->creation + TIMEOUT(*rm, PFTM_UDP_FIRST_PACKET);
+		s->packets = 1;
+		s->bytes = pd->tot_len;
+		if (pf_insert_state(s)) {
+			REASON_SET(&reason, PFRES_MEMORY);
+			pool_put(&pf_state_pl, s);
+			return (PF_DROP);
+		}
+	}
+
+	/* copy back packet headers if we performed NAT operations */
+	if (rewrite)
+		m_copyback(m, off, sizeof(*uh), (caddr_t)uh);
+
+	return (PF_PASS);
+}
+
+int
+pf_test_icmp(struct pf_rule **rm, int direction, struct ifnet *ifp,
+    struct mbuf *m, int ipoff, int off, void *h, struct pf_pdesc *pd)
+{
+	struct pf_nat *nat = NULL;
+	struct pf_binat *binat = NULL;
+	struct pf_rdr *rdr = NULL;
+	struct pf_addr *saddr = pd->src, *daddr = pd->dst, baddr;
+	struct pf_rule *r;
+	u_short reason;
+	u_int16_t icmpid = 0;
+	u_int16_t af = pd->af;
+	u_int8_t icmptype = 0, icmpcode = 0;
+	int state_icmp = 0;
+#ifdef INET6
+	int rewrite = 0;
+#endif /* INET6 */
+
+	*rm = NULL;
+
+	switch (pd->proto) {
+#ifdef INET
+	case IPPROTO_ICMP:
+		icmptype = pd->hdr.icmp->icmp_type;
+		icmpcode = pd->hdr.icmp->icmp_code;
+		icmpid = pd->hdr.icmp->icmp_id;
+
+		if (icmptype == ICMP_UNREACH ||
+		    icmptype == ICMP_SOURCEQUENCH ||
+		    icmptype == ICMP_REDIRECT ||
+		    icmptype == ICMP_TIMXCEED ||
+		    icmptype == ICMP_PARAMPROB)
+			state_icmp++;
+		break;
+#endif /* INET */
+#ifdef INET6
+	case IPPROTO_ICMPV6:
+		icmptype = pd->hdr.icmp6->icmp6_type;
+		icmpcode = pd->hdr.icmp6->icmp6_code;
+		icmpid = pd->hdr.icmp6->icmp6_id;
+
+		if (icmptype == ICMP6_DST_UNREACH ||
+		    icmptype == ICMP6_PACKET_TOO_BIG ||
+		    icmptype == ICMP6_TIME_EXCEEDED ||
+		    icmptype == ICMP6_PARAM_PROB)
+			state_icmp++;
+		break;
+#endif /* INET6 */
+	}
+
+	if (direction == PF_OUT) {
+		/* check outgoing packet for BINAT */
+		if ((binat = pf_get_binat(PF_OUT, ifp, IPPROTO_ICMP,
+		    saddr, daddr, af)) != NULL) {
+			PF_ACPY(&baddr, saddr, af);
+			switch (af) {
+#ifdef INET
+			case AF_INET:
+				pf_change_a(&saddr->v4.s_addr, pd->ip_sum,
+				    binat->raddr.addr.v4.s_addr, 0);
+				break;
+#endif /* INET */
+#ifdef INET6
+			case AF_INET6:
+				pf_change_a6(saddr, &pd->hdr.icmp6->icmp6_cksum,
+				    &binat->raddr.addr, 0);
+				rewrite++;
+				break;
+#endif /* INET6 */
+			}
+		}
+		/* check outgoing packet for NAT */
+		else if ((nat = pf_get_nat(ifp, pd->proto,
+		    saddr, 0, daddr, 0, af)) != NULL) {
+			PF_ACPY(&baddr, saddr, af);
+			switch (af) {
+#ifdef INET
+			case AF_INET:
+				pf_change_a(&saddr->v4.s_addr,
+				    pd->ip_sum, nat->raddr.addr.v4.s_addr, 0);
+				break;
+#endif /* INET */
+#ifdef INET6
+			case AF_INET6:
+				pf_change_a6(saddr, &pd->hdr.icmp6->icmp6_cksum,
+				    &nat->raddr.addr, 0);
+				rewrite++;
+				break;
+#endif /* INET6 */
+			}
+		}
+	} else {
+		/* check incoming packet for RDR */
+		if ((rdr = pf_get_rdr(ifp, pd->proto,
+		    saddr, daddr, 0, af)) != NULL) {
+			PF_ACPY(&baddr, daddr, af);
+			switch (af) {
+#ifdef INET
+			case AF_INET:
+				pf_change_a(&daddr->v4.s_addr,
+				    pd->ip_sum, rdr->raddr.addr.v4.s_addr, 0);
+				break;
+#endif /* INET */
+#ifdef INET6
+			case AF_INET6:
+				pf_change_a6(daddr, &pd->hdr.icmp6->icmp6_cksum,
+				    &rdr->raddr.addr, 0);
+				rewrite++;
+				break;
+#endif /* INET6 */
+			}
+		}
+		/* check incoming packet for BINAT */
+		else if ((binat = pf_get_binat(PF_IN, ifp, IPPROTO_ICMP,
+		    daddr, saddr, af)) != NULL) {
+			PF_ACPY(&baddr, daddr, af);
+			switch (af) {
+#ifdef INET
+			case AF_INET:
+				pf_change_a(&daddr->v4.s_addr,
+				    pd->ip_sum, binat->saddr.addr.v4.s_addr, 0);
+				break;
+#endif /* INET */
+#ifdef INET6
+			case AF_INET6:
+				pf_change_a6(daddr, &pd->hdr.icmp6->icmp6_cksum,
+				    &binat->saddr.addr, 0);
+				rewrite++;
+				break;
+#endif /* INET6 */
+			}
+		}
+	}
+
+	r = TAILQ_FIRST(pf_rules_active);
+	while (r != NULL) {
+		r->evaluations++;
+		if (r->action == PF_SCRUB)
+			r = r->skip[PF_SKIP_ACTION];
+		else if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
+		    (r->ifp == ifp && r->ifnot)))
+			r = r->skip[PF_SKIP_IFP];
+		else if (r->direction != direction)
+			r = r->skip[PF_SKIP_DIR];
+		else if (r->af && r->af != af)
+			r = r->skip[PF_SKIP_AF];
+		else if (r->proto && r->proto != pd->proto)
+			r = r->skip[PF_SKIP_PROTO];
+		else if (r->src.noroute && pf_routable(saddr, af))
+			r = TAILQ_NEXT(r, entries);
+		else if (!r->src.noroute &&
+		    !PF_AZERO(&r->src.mask, af) && !PF_MATCHA(r->src.not,
+		    &r->src.addr.addr, &r->src.mask, saddr, af))
+			r = r->skip[PF_SKIP_SRC_ADDR];
+		else if (r->dst.noroute && pf_routable(daddr, af))
+			r = TAILQ_NEXT(r, entries);
+		else if (!r->dst.noroute &&
+		    !PF_AZERO(&r->dst.mask, af) && !PF_MATCHA(r->dst.not,
+		    &r->dst.addr.addr, &r->dst.mask, daddr, af))
+			r = r->skip[PF_SKIP_DST_ADDR];
+		else if (r->type && r->type != icmptype + 1)
+			r = TAILQ_NEXT(r, entries);
+		else if (r->code && r->code != icmpcode + 1)
+			r = TAILQ_NEXT(r, entries);
+		else if (r->rule_flag & PFRULE_FRAGMENT)
+			r = TAILQ_NEXT(r, entries);
+		else {
+			*rm = r;
+			if ((*rm)->quick)
+				break;
+			r = TAILQ_NEXT(r, entries);
+		}
+	}
+
+	if (*rm != NULL) {
+		(*rm)->packets++;
+		(*rm)->bytes += pd->tot_len;
+		REASON_SET(&reason, PFRES_MATCH);
+
+		if ((*rm)->log) {
+#ifdef INET6
+			if (rewrite)
+				m_copyback(m, off, ICMP_MINLEN,
+				    (caddr_t)pd->hdr.icmp6);
+#endif /* INET6 */
+			PFLOG_PACKET(ifp, h, m, af, direction, reason, *rm);
+		}
+
+		if ((*rm)->action != PF_PASS)
+			return (PF_DROP);
+	}
+
+	if (!state_icmp && ((*rm != NULL && (*rm)->keep_state) ||
+	    nat != NULL || rdr != NULL || binat != NULL)) {
+		/* create new state */
+		struct pf_state *s = NULL;
+
+		if (*rm == NULL || !(*rm)->max_states ||
+		    (*rm)->states < (*rm)->max_states)
+			s = pool_get(&pf_state_pl, PR_NOWAIT);
+		if (s == NULL)
+			return (PF_DROP);
+		if (*rm != NULL)
+			(*rm)->states++;
+
+		s->rule.ptr = *rm;
+		s->allow_opts = *rm && (*rm)->allow_opts;
+		s->log = *rm && ((*rm)->log & 2);
+		s->proto = pd->proto;
+		s->direction = direction;
+		s->af = af;
+		if (direction == PF_OUT) {
+			PF_ACPY(&s->gwy.addr, saddr, af);
+			s->gwy.port = icmpid;
+			PF_ACPY(&s->ext.addr, daddr, af);
+			s->ext.port = icmpid;
+			if (nat != NULL || binat != NULL)
+				PF_ACPY(&s->lan.addr, &baddr, af);
+			else
+				PF_ACPY(&s->lan.addr, &s->gwy.addr, af);
+			s->lan.port = icmpid;
+		} else {
+			PF_ACPY(&s->lan.addr, daddr, af);
+			s->lan.port = icmpid;
+			PF_ACPY(&s->ext.addr, saddr, af);
+			s->ext.port = icmpid;
+			if (binat != NULL || rdr != NULL)
+				PF_ACPY(&s->gwy.addr, &baddr, af);
+			else
+				PF_ACPY(&s->gwy.addr, &s->lan.addr, af);
+			s->gwy.port = icmpid;
+		}
+		s->src.seqlo = 0;
+		s->src.seqhi = 0;
+		s->src.seqdiff = 0;
+		s->src.max_win = 0;
+		s->src.state = 0;
+		s->dst.seqlo = 0;
+		s->dst.seqhi = 0;
+		s->dst.seqdiff = 0;
+		s->dst.max_win = 0;
+		s->dst.state = 0;
+		s->creation = time.tv_sec;
+		s->expire = s->creation + TIMEOUT(*rm, PFTM_ICMP_FIRST_PACKET);
+		s->packets = 1;
+		s->bytes = pd->tot_len;
+		if (pf_insert_state(s)) {
+			REASON_SET(&reason, PFRES_MEMORY);
+			pool_put(&pf_state_pl, s);
+			return (PF_DROP);
+		}
+	}
+
+#ifdef INET6
+	/* copy back packet headers if we performed IPv6 NAT operations */
+	if (rewrite)
+		m_copyback(m, off, ICMP_MINLEN,
+		    (caddr_t)pd->hdr.icmp6);
+#endif /* INET6 */
+
+	return (PF_PASS);
+}
+
+int
+pf_test_other(struct pf_rule **rm, int direction, struct ifnet *ifp,
+    struct mbuf *m, void *h, struct pf_pdesc *pd)
+{
+	struct pf_rule *r;
+	struct pf_nat *nat = NULL;
+	struct pf_binat *binat = NULL;
+	struct pf_rdr *rdr = NULL;
+	struct pf_addr *saddr = pd->src, *daddr = pd->dst, baddr;
+	u_int8_t af = pd->af;
+	u_short reason;
+
+
+	*rm = NULL;
+
+	if (direction == PF_OUT) {
+		/* check outgoing packet for BINAT */
+		if ((binat = pf_get_binat(PF_OUT, ifp, pd->proto,
+		    saddr, daddr, af)) != NULL) {
+			PF_ACPY(&baddr, saddr, af);
+			switch (af) {
+#ifdef INET
+			case AF_INET:
+				pf_change_a(&saddr->v4.s_addr, pd->ip_sum,
+				    binat->raddr.addr.v4.s_addr, 0);
+				break;
+#endif /* INET */
+#ifdef INET6
+			case AF_INET6:
+				PF_ACPY(saddr, &binat->raddr.addr, af);
+				break;
+#endif /* INET6 */
+			}
+		}
+		/* check outgoing packet for NAT */
+		else if ((nat = pf_get_nat(ifp, pd->proto,
+		    saddr, 0, daddr, 0, af)) != NULL) {
+			PF_ACPY(&baddr, saddr, af);
+			switch (af) {
+#ifdef INET
+			case AF_INET:
+				pf_change_a(&saddr->v4.s_addr,
+				    pd->ip_sum, nat->raddr.addr.v4.s_addr, 0);
+				break;
+#endif /* INET */
+#ifdef INET6
+			case AF_INET6:
+				PF_ACPY(saddr, &nat->raddr.addr, af);
+				break;
+#endif /* INET6 */
+			}
+		}
+	} else {
+		/* check incoming packet for RDR */
+		if ((rdr = pf_get_rdr(ifp, pd->proto,
+		    saddr, daddr, 0, af)) != NULL) {
+			PF_ACPY(&baddr, daddr, af);
+			switch (af) {
+#ifdef INET
+			case AF_INET:
+				pf_change_a(&daddr->v4.s_addr,
+				    pd->ip_sum, rdr->raddr.addr.v4.s_addr, 0);
+				break;
+#endif /* INET */
+#ifdef INET6
+			case AF_INET6:
+				PF_ACPY(daddr, &rdr->raddr.addr, af);
+				break;
+#endif /* INET6 */
+			}
+		}
+		/* check incoming packet for BINAT */
+		else if ((binat = pf_get_binat(PF_IN, ifp, pd->proto,
+		    daddr, saddr, af)) != NULL) {
+			PF_ACPY(&baddr, daddr, af);
+			switch (af) {
+#ifdef INET
+			case AF_INET:
+				pf_change_a(&daddr->v4.s_addr,
+				    pd->ip_sum, binat->saddr.addr.v4.s_addr, 0);
+				break;
+#endif /* INET */
+#ifdef INET6
+			case AF_INET6:
+				PF_ACPY(daddr, &binat->saddr.addr, af);
+				break;
+#endif /* INET6 */
+			}
+		}
+	}
+
+	r = TAILQ_FIRST(pf_rules_active);
+	while (r != NULL) {
+		r->evaluations++;
+		if (r->action == PF_SCRUB)
+			r = r->skip[PF_SKIP_ACTION];
+		else if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
+		    (r->ifp == ifp && r->ifnot)))
+			r = r->skip[PF_SKIP_IFP];
+		else if (r->direction != direction)
+			r = r->skip[PF_SKIP_DIR];
+		else if (r->af && r->af != af)
+			r = r->skip[PF_SKIP_AF];
+		else if (r->proto && r->proto != pd->proto)
+			r = r->skip[PF_SKIP_PROTO];
+		else if (r->src.noroute && pf_routable(pd->src, af))
+			r = TAILQ_NEXT(r, entries);
+		else if (!r->src.noroute &&
+		    !PF_AZERO(&r->src.mask, af) && !PF_MATCHA(r->src.not,
+		    &r->src.addr.addr, &r->src.mask, pd->src, af))
+			r = r->skip[PF_SKIP_SRC_ADDR];
+		else if (r->dst.noroute && pf_routable(pd->dst, af))
+			r = TAILQ_NEXT(r, entries);
+		else if (!r->src.noroute &&
+		    !PF_AZERO(&r->dst.mask, af) && !PF_MATCHA(r->dst.not,
+		    &r->dst.addr.addr, &r->dst.mask, pd->dst, af))
+			r = r->skip[PF_SKIP_DST_ADDR];
+		else if (r->rule_flag & PFRULE_FRAGMENT)
+			r = TAILQ_NEXT(r, entries);
+		else {
+			*rm = r;
+			if ((*rm)->quick)
+				break;
+			r = TAILQ_NEXT(r, entries);
+		}
+	}
+
+	if (*rm != NULL) {
+		(*rm)->packets++;
+		(*rm)->bytes += pd->tot_len;
+		REASON_SET(&reason, PFRES_MATCH);
+		if ((*rm)->log)
+			PFLOG_PACKET(ifp, h, m, af, direction, reason, *rm);
+
+		if ((*rm)->action != PF_PASS)
+			return (PF_DROP);
+	}
+
+	if ((*rm != NULL && (*rm)->keep_state) || nat != NULL ||
+	    rdr != NULL || binat != NULL) {
+		/* create new state */
+		struct pf_state *s = NULL;
+
+		if (*rm == NULL || !(*rm)->max_states ||
+		    (*rm)->states < (*rm)->max_states)
+			s = pool_get(&pf_state_pl, PR_NOWAIT);
+		if (s == NULL)
+			return (PF_DROP);
+		if (*rm != NULL)
+			(*rm)->states++;
+
+		s->rule.ptr = *rm;
+		s->allow_opts = *rm && (*rm)->allow_opts;
+		s->log = *rm && ((*rm)->log & 2);
+		s->proto = pd->proto;
+		s->direction = direction;
+		s->af = af;
+		if (direction == PF_OUT) {
+			PF_ACPY(&s->gwy.addr, saddr, af);
+			s->gwy.port = 0;
+			PF_ACPY(&s->ext.addr, daddr, af);
+			s->ext.port = 0;
+			if (nat != NULL || binat != NULL)
+				PF_ACPY(&s->lan.addr, &baddr, af);
+			else
+				PF_ACPY(&s->lan.addr, &s->gwy.addr, af);
+			s->lan.port = 0;
+		} else {
+			PF_ACPY(&s->lan.addr, daddr, af);
+			s->lan.port = 0;
+			PF_ACPY(&s->ext.addr, saddr, af);
+			s->ext.port = 0;
+			if (binat != NULL || rdr != NULL)
+				PF_ACPY(&s->gwy.addr, &baddr, af);
+			else
+				PF_ACPY(&s->gwy.addr, &s->lan.addr, af);
+			s->gwy.port = 0;
+		}
+		s->src.seqlo = 0;
+		s->src.seqhi = 0;
+		s->src.seqdiff = 0;
+		s->src.max_win = 0;
+		s->src.state = PFOTHERS_SINGLE;
+		s->dst.seqlo = 0;
+		s->dst.seqhi = 0;
+		s->dst.seqdiff = 0;
+		s->dst.max_win = 0;
+		s->dst.state = PFOTHERS_NO_TRAFFIC;
+		s->creation = time.tv_sec;
+		s->expire = s->creation + TIMEOUT(*rm, PFTM_OTHER_FIRST_PACKET);
+		s->packets = 1;
+		s->bytes = pd->tot_len;
+		if (pf_insert_state(s)) {
+			REASON_SET(&reason, PFRES_MEMORY);
+			if (*rm && (*rm)->log)
+				PFLOG_PACKET(ifp, h, m, af, direction, reason,
+				    *rm);
+			pool_put(&pf_state_pl, s);
+			return (PF_DROP);
+		}
+	}
+
+	return (PF_PASS);
+}
+
+int
+pf_test_fragment(struct pf_rule **rm, int direction, struct ifnet *ifp,
+    struct mbuf *m, void *h, struct pf_pdesc *pd)
+{
+	struct pf_rule *r;
+	u_int8_t af = pd->af;
+
+	*rm = NULL;
+
+	r = TAILQ_FIRST(pf_rules_active);
+	while (r != NULL) {
+		r->evaluations++;
+		if (r->action == PF_SCRUB)
+			r = r->skip[PF_SKIP_ACTION];
+		else if (r->ifp != NULL && ((r->ifp != ifp && !r->ifnot) ||
+		    (r->ifp == ifp && r->ifnot)))
+			r = r->skip[PF_SKIP_IFP];
+		else if (r->direction != direction)
+			r = r->skip[PF_SKIP_DIR];
+		else if (r->af && r->af != af)
+			r = r->skip[PF_SKIP_AF];
+		else if (r->proto && r->proto != pd->proto)
+			r = r->skip[PF_SKIP_PROTO];
+		else if (r->src.noroute && pf_routable(pd->src, af))
+			r = TAILQ_NEXT(r, entries);
+		else if (!r->src.noroute &&
+		    !PF_AZERO(&r->src.mask, af) && !PF_MATCHA(r->src.not,
+		    &r->src.addr.addr, &r->src.mask, pd->src, af))
+			r = r->skip[PF_SKIP_SRC_ADDR];
+		else if (r->dst.noroute && pf_routable(pd->dst, af))
+			r = TAILQ_NEXT(r, entries);
+		else if (!r->src.noroute &&
+		    !PF_AZERO(&r->dst.mask, af) && !PF_MATCHA(r->dst.not,
+		    &r->dst.addr.addr, &r->dst.mask, pd->dst, af))
+			r = r->skip[PF_SKIP_DST_ADDR];
+		else if (r->src.port_op || r->dst.port_op ||
+		    r->flagset || r->type || r->code)
+			r = TAILQ_NEXT(r, entries);
+		else {
+			*rm = r;
+			if ((*rm)->quick)
+				break;
+			r = TAILQ_NEXT(r, entries);
+		}
+	}
+
+	if (*rm != NULL) {
+		u_short reason;
+
+		(*rm)->packets++;
+		(*rm)->bytes += pd->tot_len;
+		REASON_SET(&reason, PFRES_MATCH);
+		if ((*rm)->log)
+			PFLOG_PACKET(ifp, h, m, af, direction, reason, *rm);
+
+		if ((*rm)->action != PF_PASS)
+			return (PF_DROP);
+	}
+
+	return (PF_PASS);
+}
+
+int
+pf_test_state_tcp(struct pf_state **state, int direction, struct ifnet *ifp,
+    struct mbuf *m, int ipoff, int off, void *h, struct pf_pdesc *pd)
+{
+	struct pf_tree_node key;
+	struct tcphdr *th = pd->hdr.tcp;
+	u_int16_t win = ntohs(th->th_win);
+	u_int32_t ack, end, seq;
+	int ackskew;
+	struct pf_state_peer *src, *dst;
+
+	key.af = pd->af;
+	key.proto = IPPROTO_TCP;
+	PF_ACPY(&key.addr[0], pd->src, key.af);
+	PF_ACPY(&key.addr[1], pd->dst, key.af);
+	key.port[0] = th->th_sport;
+	key.port[1] = th->th_dport;
+
+	if (direction == PF_IN)
+		*state = pf_find_state(&tree_ext_gwy, &key);
+	else
+		*state = pf_find_state(&tree_lan_ext, &key);
+	if (*state == NULL)
+		return (PF_DROP);
+
+	if (direction == (*state)->direction) {
+		src = &(*state)->src;
+		dst = &(*state)->dst;
+	} else {
+		src = &(*state)->dst;
+		dst = &(*state)->src;
+	}
+
+	/*
+	 * Sequence tracking algorithm from Guido van Rooij's paper:
+	 *   http://www.madison-gurkha.com/publications/tcp_filtering/
+	 *	tcp_filtering.ps
+	 */
+
+	seq = ntohl(th->th_seq);
+	if (src->seqlo == 0) {
+		/* First packet from this end. Set its state */
+
+		/* Deferred generation of sequence number modulator */
+		if (dst->seqdiff) {
+			while ((src->seqdiff = arc4random()) == 0)
+				;
+			ack = ntohl(th->th_ack) - dst->seqdiff;
+			pf_change_a(&th->th_seq, &th->th_sum, htonl(seq +
+			    src->seqdiff), 0);
+			pf_change_a(&th->th_ack, &th->th_sum, htonl(ack), 0);
+		} else {
+			ack = ntohl(th->th_ack);
+		}
+
+		end = seq + pd->p_len;
+		if (th->th_flags & TH_SYN)
+			end++;
+		if (th->th_flags & TH_FIN)
+			end++;
+
+		src->seqlo = seq;
+		if (src->state < TCPS_SYN_SENT)
+			src->state = TCPS_SYN_SENT;
+
+		/*
+		 * May need to slide the window (seqhi may have been set by
+		 * the crappy stack check or if we picked up the connection
+		 * after establishment)
+		 */
+		if (src->seqhi == 1 ||
+		    SEQ_GEQ(end + MAX(1, dst->max_win), src->seqhi))
+			src->seqhi = end + MAX(1, dst->max_win);
+		if (win > src->max_win)
+			src->max_win = win;
+
+	} else {
+		ack = ntohl(th->th_ack) - dst->seqdiff;
+		if (src->seqdiff) {
+			/* Modulate sequence numbers */
+			pf_change_a(&th->th_seq, &th->th_sum, htonl(seq +
+			    src->seqdiff), 0);
+			pf_change_a(&th->th_ack, &th->th_sum, htonl(ack), 0);
+		}
+		end = seq + pd->p_len;
+		if (th->th_flags & TH_SYN)
+			end++;
+		if (th->th_flags & TH_FIN)
+			end++;
+	}
+
+	if ((th->th_flags & TH_ACK) == 0) {
+		/* Let it pass through the ack skew check */
+		ack = dst->seqlo;
+	} else if ((ack == 0 &&
+	    (th->th_flags & (TH_ACK|TH_RST)) == (TH_ACK|TH_RST)) ||
+	    /* broken tcp stacks do not set ack */
+	    (dst->state < TCPS_SYN_SENT)) {
+	    /* Many stacks (ours included) will set the ACK number in an
+	     * FIN|ACK if the SYN times out -- no sequence to ACK.
+	     */
+		ack = dst->seqlo;
+	}
+
+	if (seq == end) {
+		/* Ease sequencing restrictions on no data packets */
+		seq = src->seqlo;
+		end = seq;
+	}
+
+	ackskew = dst->seqlo - ack;
+
+#define MAXACKWINDOW (0xffff + 1500)	/* 1500 is an arbitrary fudge factor */
+	if (SEQ_GEQ(src->seqhi, end) &&
+	    /* Last octet inside other's window space */
+	    SEQ_GEQ(seq, src->seqlo - dst->max_win) &&
+	    /* Retrans: not more than one window back */
+	    (ackskew >= -MAXACKWINDOW) &&
+	    /* Acking not more than one window back */
+	    (ackskew <= MAXACKWINDOW)) {
+	    /* Acking not more than one window forward */
+
+		(*state)->packets++;
+		(*state)->bytes += pd->tot_len;
+
+		/* update max window */
+		if (src->max_win < win)
+			src->max_win = win;
+		/* synchronize sequencing */
+		if (SEQ_GT(end, src->seqlo))
+			src->seqlo = end;
+		/* slide the window of what the other end can send */
+		if (SEQ_GEQ(ack + win, dst->seqhi))
+			dst->seqhi = ack + MAX(win, 1);
+
+		/* update states */
+		if (th->th_flags & TH_SYN)
+			if (src->state < TCPS_SYN_SENT)
+				src->state = TCPS_SYN_SENT;
+		if (th->th_flags & TH_FIN)
+			if (src->state < TCPS_CLOSING)
+				src->state = TCPS_CLOSING;
+		if (th->th_flags & TH_ACK) {
+			if (dst->state == TCPS_SYN_SENT)
+				dst->state = TCPS_ESTABLISHED;
+			else if (dst->state == TCPS_CLOSING)
+				dst->state = TCPS_FIN_WAIT_2;
+		}
+		if (th->th_flags & TH_RST)
+			src->state = dst->state = TCPS_TIME_WAIT;
+
+		/* update expire time */
+		if (src->state >= TCPS_FIN_WAIT_2 &&
+		    dst->state >= TCPS_FIN_WAIT_2)
+			(*state)->expire = time.tv_sec + 
+			    TIMEOUT((*state)->rule.ptr, PFTM_TCP_CLOSED);
+		else if (src->state >= TCPS_FIN_WAIT_2 ||
+		    dst->state >= TCPS_FIN_WAIT_2)
+			(*state)->expire = time.tv_sec +
+			    TIMEOUT((*state)->rule.ptr, PFTM_TCP_FIN_WAIT);
+		else if (src->state >= TCPS_CLOSING ||
+		    dst->state >= TCPS_CLOSING)
+			(*state)->expire = time.tv_sec +
+			    TIMEOUT((*state)->rule.ptr, PFTM_TCP_CLOSING);
+		else if (src->state < TCPS_ESTABLISHED ||
+		    dst->state < TCPS_ESTABLISHED)
+			(*state)->expire = time.tv_sec +
+			    TIMEOUT((*state)->rule.ptr, PFTM_TCP_OPENING);
+		else
+			(*state)->expire = time.tv_sec +
+			    TIMEOUT((*state)->rule.ptr, PFTM_TCP_ESTABLISHED);
+
+		/* Fall through to PASS packet */
+
+	} else if ((dst->state < TCPS_SYN_SENT ||
+		dst->state >= TCPS_FIN_WAIT_2 ||
+		src->state >= TCPS_FIN_WAIT_2) &&
+	    SEQ_GEQ(src->seqhi + MAXACKWINDOW, end) &&
+	    /* Within a window forward of the originating packet */
+	    SEQ_GEQ(seq, src->seqlo - MAXACKWINDOW)) {
+	    /* Within a window backward of the originating packet */
+
+		/*
+		 * This currently handles three situations:
+		 *  1) Stupid stacks will shotgun SYNs before their peer
+		 *     replies.
+		 *  2) When PF catches an already established stream (the
+		 *     firewall rebooted, the state table was flushed, routes
+		 *     changed...)
+		 *  3) Packets get funky immediately after the connection
+		 *     closes (this should catch Solaris spurious ACK|FINs
+		 *     that web servers like to spew after a close)
+		 *
+		 * This must be a little more careful than the above code
+		 * since packet floods will also be caught here. We don't
+		 * update the TTL here to mitigate the damage of a packet
+		 * flood and so the same code can handle awkward establishment
+		 * and a loosened connection close.
+		 * In the establishment case, a correct peer response will
+		 * validate the connection, go through the normal state code
+		 * and keep updating the state TTL.
+		 */
+		
+		if (pf_status.debug >= PF_DEBUG_MISC) {
+			printf("pf: loose state match: ");
+			pf_print_state(*state);
+			pf_print_flags(th->th_flags);
+			printf(" seq=%u ack=%u len=%u ackskew=%d pkts=%d\n",
+			    seq, ack, pd->p_len, ackskew, (*state)->packets);
+		}
+
+		(*state)->packets++;
+		(*state)->bytes += pd->tot_len;
+
+		/* update max window */
+		if (src->max_win < win)
+			src->max_win = win;
+		/* synchronize sequencing */
+		if (SEQ_GT(end, src->seqlo))
+			src->seqlo = end;
+		/* slide the window of what the other end can send */
+		if (SEQ_GEQ(ack + win, dst->seqhi))
+			dst->seqhi = ack + MAX(win, 1);
+
+		/*
+		 * Cannot set dst->seqhi here since this could be a shotgunned
+		 * SYN and not an already established connection.
+		 */
+
+		if (th->th_flags & TH_FIN)
+			if (src->state < TCPS_CLOSING)
+				src->state = TCPS_CLOSING;
+		if (th->th_flags & TH_RST)
+			src->state = dst->state = TCPS_TIME_WAIT;
+
+		/* Fall through to PASS packet */
+
+	} else {
+		if (pf_status.debug >= PF_DEBUG_MISC) {
+			printf("pf: BAD state: ");
+			pf_print_state(*state);
+			pf_print_flags(th->th_flags);
+			printf(" seq=%u ack=%u len=%u ackskew=%d pkts=%d "
+			    "dir=%s,%s\n", seq, ack, pd->p_len, ackskew,
+			    ++(*state)->packets,
+			    direction == PF_IN ? "in" : "out",
+			    direction == (*state)->direction ? "fwd" : "rev");
+			printf("pf: State failure on: %c %c %c %c | %c %c\n",
+			    SEQ_GEQ(src->seqhi, end) ? ' ' : '1',
+			    SEQ_GEQ(seq, src->seqlo - dst->max_win) ? ' ': '2',
+			    (ackskew >= -MAXACKWINDOW) ? ' ' : '3',
+			    (ackskew <= MAXACKWINDOW) ? ' ' : '4',
+			    SEQ_GEQ(src->seqhi + MAXACKWINDOW, end) ?' ' :'5',
+			    SEQ_GEQ(seq, src->seqlo - MAXACKWINDOW) ?' ' :'6');
+		}
+		return (PF_DROP);
+	}
+
+	/* Any packets which have gotten here are to be passed */
+
+	/* translate source/destination address, if needed */
+	if (STATE_TRANSLATE(*state)) {
+		if (direction == PF_OUT)
+			pf_change_ap(pd->src, &th->th_sport, pd->ip_sum,
+			    &th->th_sum, &(*state)->gwy.addr,
+			    (*state)->gwy.port, 0, pd->af);
+		else
+			pf_change_ap(pd->dst, &th->th_dport, pd->ip_sum,
+			    &th->th_sum, &(*state)->lan.addr,
+			    (*state)->lan.port, 0, pd->af);
+		m_copyback(m, off, sizeof(*th), (caddr_t)th);
+	} else if (src->seqdiff) {
+		/* Copyback sequence modulation */
+		m_copyback(m, off, sizeof(*th), (caddr_t)th);
+	}
+
+	if ((*state)->rule.ptr != NULL) {
+		(*state)->rule.ptr->packets++;
+		(*state)->rule.ptr->bytes += pd->tot_len;
+	}
+
+	return (PF_PASS);
+}
+
+int
+pf_test_state_udp(struct pf_state **state, int direction, struct ifnet *ifp,
+    struct mbuf *m, int ipoff, int off, void *h, struct pf_pdesc *pd)
+{
+	struct pf_state_peer *src, *dst;
+	struct pf_tree_node key;
+	struct udphdr *uh = pd->hdr.udp;
+
+	key.af = pd->af;
+	key.proto = IPPROTO_UDP;
+	PF_ACPY(&key.addr[0], pd->src, key.af);
+	PF_ACPY(&key.addr[1], pd->dst, key.af);
+	key.port[0] = pd->hdr.udp->uh_sport;
+	key.port[1] = pd->hdr.udp->uh_dport;
+
+	if (direction == PF_IN)
+		*state = pf_find_state(&tree_ext_gwy, &key);
+	else
+		*state = pf_find_state(&tree_lan_ext, &key);
+	if (*state == NULL)
+		return (PF_DROP);
+
+	if (direction == (*state)->direction) {
+		src = &(*state)->src;
+		dst = &(*state)->dst;
+	} else {
+		src = &(*state)->dst;
+		dst = &(*state)->src;
+	}
+
+	(*state)->packets++;
+	(*state)->bytes += pd->tot_len;
+
+	/* update states */
+	if (src->state < PFUDPS_SINGLE)
+		src->state = PFUDPS_SINGLE;
+	if (dst->state == PFUDPS_SINGLE)
+		dst->state = PFUDPS_MULTIPLE;
+
+	/* update expire time */
+	if (src->state == PFUDPS_MULTIPLE && dst->state == PFUDPS_MULTIPLE)
+		(*state)->expire = time.tv_sec +
+		    TIMEOUT((*state)->rule.ptr, PFTM_UDP_MULTIPLE);
+	else
+		(*state)->expire = time.tv_sec +
+		    TIMEOUT((*state)->rule.ptr, PFTM_UDP_SINGLE);
+
+	/* translate source/destination address, if necessary */
+	if (STATE_TRANSLATE(*state)) {
+		if (direction == PF_OUT)
+			pf_change_ap(pd->src, &uh->uh_sport, pd->ip_sum,
+			    &uh->uh_sum, &(*state)->gwy.addr,
+			    (*state)->gwy.port, 1, pd->af);
+		else
+			pf_change_ap(pd->dst, &uh->uh_dport, pd->ip_sum,
+			    &uh->uh_sum, &(*state)->lan.addr,
+			    (*state)->lan.port, 1, pd->af);
+		m_copyback(m, off, sizeof(*uh), (caddr_t)uh);
+	}
+
+	if ((*state)->rule.ptr != NULL) {
+		(*state)->rule.ptr->packets++;
+		(*state)->rule.ptr->bytes += pd->tot_len;
+	}
+	return (PF_PASS);
+}
+
+int
+pf_test_state_icmp(struct pf_state **state, int direction, struct ifnet *ifp,
+    struct mbuf *m, int ipoff, int off, void *h, struct pf_pdesc *pd)
+{
+	struct pf_addr *saddr = pd->src, *daddr = pd->dst;
+	u_int16_t icmpid = 0;
+	u_int16_t *icmpsum = 0;
+	u_int8_t icmptype = 0;
+	int state_icmp = 0;
+
+	switch (pd->proto) {
+#ifdef INET
+	case IPPROTO_ICMP:
+		icmptype = pd->hdr.icmp->icmp_type;
+		icmpid = pd->hdr.icmp->icmp_id;
+		icmpsum = &pd->hdr.icmp->icmp_cksum;
+
+		if (icmptype == ICMP_UNREACH ||
+		    icmptype == ICMP_SOURCEQUENCH ||
+		    icmptype == ICMP_REDIRECT ||
+		    icmptype == ICMP_TIMXCEED ||
+		    icmptype == ICMP_PARAMPROB)
+			state_icmp++;
+		break;
+#endif /* INET */
+#ifdef INET6
+	case IPPROTO_ICMPV6:
+		icmptype = pd->hdr.icmp6->icmp6_type;
+		icmpid = pd->hdr.icmp6->icmp6_id;
+		icmpsum = &pd->hdr.icmp6->icmp6_cksum;
+
+		if (icmptype == ICMP6_DST_UNREACH ||
+		    icmptype == ICMP6_PACKET_TOO_BIG ||
+		    icmptype == ICMP6_TIME_EXCEEDED ||
+		    icmptype == ICMP6_PARAM_PROB)
+			state_icmp++;
+		break;
+#endif /* INET6 */
+	}
+
+	if (!state_icmp) {
+
+		/*
+		 * ICMP query/reply message not related to a TCP/UDP packet.
+		 * Search for an ICMP state.
+		 */
+		struct pf_tree_node key;
+
+		key.af = pd->af;
+		key.proto = pd->proto;
+		PF_ACPY(&key.addr[0], saddr, key.af);
+		PF_ACPY(&key.addr[1], daddr, key.af);
+		key.port[0] = icmpid;
+		key.port[1] = icmpid;
+
+		if (direction == PF_IN)
+			*state = pf_find_state(&tree_ext_gwy, &key);
+		else
+			*state = pf_find_state(&tree_lan_ext, &key);
+		if (*state == NULL)
+			return (PF_DROP);
+
+		(*state)->packets++;
+		(*state)->bytes += pd->tot_len;
+		(*state)->expire = time.tv_sec +
+		    TIMEOUT((*state)->rule.ptr, PFTM_ICMP_ERROR_REPLY);
+
+		/* translate source/destination address, if needed */
+		if (PF_ANEQ(&(*state)->lan.addr, &(*state)->gwy.addr, pd->af)) {
+			if (direction == PF_OUT) {
+				switch (pd->af) {
+#ifdef INET
+				case AF_INET:
+					pf_change_a(&saddr->v4.s_addr,
+					    pd->ip_sum,
+					    (*state)->gwy.addr.v4.s_addr, 0);
+					break;
+#endif /* INET */
+#ifdef INET6
+				case AF_INET6:
+					pf_change_a6(saddr,
+					    &pd->hdr.icmp6->icmp6_cksum,
+					    &(*state)->gwy.addr, 0);
+					m_copyback(m, off, ICMP_MINLEN,
+					    (caddr_t)pd->hdr.icmp6);
+					break;
+#endif /* INET6 */
+				}
+			} else {
+				switch (pd->af) {
+#ifdef INET
+				case AF_INET:
+					pf_change_a(&daddr->v4.s_addr,
+					    pd->ip_sum,
+					    (*state)->lan.addr.v4.s_addr, 0);
+					break;
+#endif /* INET */
+#ifdef INET6
+				case AF_INET6:
+					pf_change_a6(daddr,
+					    &pd->hdr.icmp6->icmp6_cksum,
+					    &(*state)->lan.addr, 0);
+					m_copyback(m, off, ICMP_MINLEN,
+					    (caddr_t)pd->hdr.icmp6);
+					break;
+#endif /* INET6 */
+				}
+			}
+		}
+
+		return (PF_PASS);
+
+	} else {
+		/*
+		 * ICMP error message in response to a TCP/UDP packet.
+		 * Extract the inner TCP/UDP header and search for that state.
+		 */
+
+		struct pf_pdesc pd2;
+#ifdef INET
+		struct ip h2;
+#endif /* INET */
+#ifdef INET6
+		struct ip6_hdr h2_6;
+		int terminal = 0;
+#endif /* INET6 */
+		int ipoff2 = 0;
+		int off2 = 0;
+
+		pd2.af = pd->af;
+		switch (pd->af) {
+#ifdef INET
+		case AF_INET:
+			/* offset of h2 in mbuf chain */
+			ipoff2 = off + ICMP_MINLEN;
+
+			if (!pf_pull_hdr(m, ipoff2, &h2, sizeof(h2),
+			    NULL, NULL, pd2.af)) {
+				DPFPRINTF(PF_DEBUG_MISC,
+				    ("pf: ICMP error message too short (ip)\n"));
+				return (PF_DROP);
+			}
+			/* ICMP error messages don't refer to non-first fragments */
+			if (ntohs(h2.ip_off) & IP_OFFMASK)
+				return (PF_DROP);
+
+			/* offset of protocol header that follows h2 */
+			off2 = ipoff2 + (h2.ip_hl << 2);
+
+			pd2.proto = h2.ip_p;
+			pd2.src = (struct pf_addr *)&h2.ip_src;
+			pd2.dst = (struct pf_addr *)&h2.ip_dst;
+			pd2.ip_sum = &h2.ip_sum;
+			break;
+#endif /* INET */
+#ifdef INET6
+		case AF_INET6:
+			ipoff2 = off + sizeof(struct icmp6_hdr);
+
+			if (!pf_pull_hdr(m, ipoff2, &h2_6, sizeof(h2_6),
+			    NULL, NULL, pd2.af)) {
+				DPFPRINTF(PF_DEBUG_MISC,
+				    ("pf: ICMP error message too short (ip6)\n"));
+				return (PF_DROP);
+			}
+			pd2.proto = h2_6.ip6_nxt;
+			pd2.src = (struct pf_addr *)&h2_6.ip6_src;
+			pd2.dst = (struct pf_addr *)&h2_6.ip6_dst;
+			pd2.ip_sum = NULL;
+			off2 = ipoff2 + sizeof(h2_6);
+			do {
+				switch (pd2.proto) {
+				case IPPROTO_FRAGMENT:
+					/*
+					 * ICMPv6 error messages for
+					 * non-first fragments
+					 */
+					return (PF_DROP);
+				case IPPROTO_AH:
+				case IPPROTO_HOPOPTS:
+				case IPPROTO_ROUTING:
+				case IPPROTO_DSTOPTS: {
+					/* get next header and header length */
+					struct ip6_ext opt6;
+
+					if (!pf_pull_hdr(m, off2, &opt6,
+					    sizeof(opt6), NULL, NULL, pd2.af)) {
+						DPFPRINTF(PF_DEBUG_MISC,
+						    ("pf: ICMPv6 short opt\n"));
+						return (PF_DROP);
+					}
+					if (pd2.proto == IPPROTO_AH)
+						off2 += (opt6.ip6e_len + 2) * 4;
+					else
+						off2 += (opt6.ip6e_len + 1) * 8;
+					pd2.proto = opt6.ip6e_nxt;
+					/* goto the next header */
+					break;
+				}
+				default:
+					terminal++;
+					break;
+				}
+			} while (!terminal);
+			break;
+#endif /* INET6 */
+		}
+
+		switch (pd2.proto) {
+		case IPPROTO_TCP: {
+			struct tcphdr th;
+			u_int32_t seq;
+			struct pf_tree_node key;
+			struct pf_state_peer *src, *dst;
+
+			/*
+			 * Only the first 8 bytes of the TCP header can be
+			 * expected. Don't access any TCP header fields after
+			 * th_seq, an ackskew test is not possible.
+			 */
+			if (!pf_pull_hdr(m, off2, &th, 8, NULL, NULL, pd2.af)) {
+				DPFPRINTF(PF_DEBUG_MISC,
+				    ("pf: ICMP error message too short (tcp)\n"));
+				return (PF_DROP);
+			}
+
+			key.af = pd2.af;
+			key.proto = IPPROTO_TCP;
+			PF_ACPY(&key.addr[0], pd2.dst, pd2.af);
+			key.port[0] = th.th_dport;
+			PF_ACPY(&key.addr[1], pd2.src, pd2.af);
+			key.port[1] = th.th_sport;
+
+			if (direction == PF_IN)
+				*state = pf_find_state(&tree_ext_gwy, &key);
+			else
+				*state = pf_find_state(&tree_lan_ext, &key);
+			if (*state == NULL)
+				return (PF_DROP);
+
+			if (direction == (*state)->direction) {
+				src = &(*state)->dst;
+				dst = &(*state)->src;
+			} else {
+				src = &(*state)->src;
+				dst = &(*state)->dst;
+			}
+
+			/* Demodulate sequence number */
+			seq = ntohl(th.th_seq) - src->seqdiff;
+			if (src->seqdiff)
+				pf_change_a(&th.th_seq, &th.th_sum,
+				    htonl(seq), 0);
+
+			if (!SEQ_GEQ(src->seqhi, seq) ||
+			    !SEQ_GEQ(seq, src->seqlo - dst->max_win)) {
+				if (pf_status.debug >= PF_DEBUG_MISC) {
+					printf("pf: BAD ICMP state: ");
+					pf_print_state(*state);
+					printf(" seq=%u\n", seq);
+				}
+				return (PF_DROP);
+			}
+
+			if (STATE_TRANSLATE(*state)) {
+				if (direction == PF_IN) {
+					pf_change_icmp(pd2.src, &th.th_sport,
+					    saddr, &(*state)->lan.addr,
+					    (*state)->lan.port, NULL,
+					    pd2.ip_sum, icmpsum,
+					    pd->ip_sum, 0, pd2.af);
+				} else {
+					pf_change_icmp(pd2.dst, &th.th_dport,
+					    saddr, &(*state)->gwy.addr,
+					    (*state)->gwy.port, NULL,
+					    pd2.ip_sum, icmpsum,
+					    pd->ip_sum, 0, pd2.af);
+				}
+				switch (pd2.af) {
+#ifdef INET
+				case AF_INET:
+					m_copyback(m, off, ICMP_MINLEN,
+					    (caddr_t)pd->hdr.icmp);
+					m_copyback(m, ipoff2, sizeof(h2),
+					    (caddr_t)&h2);
+					break;
+#endif /* INET */
+#ifdef INET6
+				case AF_INET6:
+					m_copyback(m, off, ICMP_MINLEN,
+					    (caddr_t)pd->hdr.icmp6);
+					m_copyback(m, ipoff2, sizeof(h2_6),
+					    (caddr_t)&h2_6);
+					break;
+#endif /* INET6 */
+				}
+				m_copyback(m, off2, 8, (caddr_t)&th);
+			} else if (src->seqdiff) {
+				m_copyback(m, off2, 8, (caddr_t)&th);
+			}
+
+			return (PF_PASS);
+			break;
+		}
+		case IPPROTO_UDP: {
+			struct udphdr uh;
+			struct pf_tree_node key;
+
+			if (!pf_pull_hdr(m, off2, &uh, sizeof(uh),
+			    NULL, NULL, pd2.af)) {
+				DPFPRINTF(PF_DEBUG_MISC,
+				    ("pf: ICMP error message too short (udp)\n"));
+				return (PF_DROP);
+			}
+
+			key.af = pd2.af;
+			key.proto = IPPROTO_UDP;
+			PF_ACPY(&key.addr[0], pd2.dst, pd2.af);
+			key.port[0] = uh.uh_dport;
+			PF_ACPY(&key.addr[1], pd2.src, pd2.af);
+			key.port[1] = uh.uh_sport;
+
+			if (direction == PF_IN)
+				*state = pf_find_state(&tree_ext_gwy, &key);
+			else
+				*state = pf_find_state(&tree_lan_ext, &key);
+			if (*state == NULL)
+				return (PF_DROP);
+
+			if (STATE_TRANSLATE(*state)) {
+				if (direction == PF_IN) {
+					pf_change_icmp(pd2.src, &uh.uh_sport,
+					    daddr, &(*state)->lan.addr,
+					    (*state)->lan.port, &uh.uh_sum,
+					    pd2.ip_sum, icmpsum,
+					    pd->ip_sum, 1, pd2.af);
+				} else {
+					pf_change_icmp(pd2.dst, &uh.uh_dport,
+					    saddr, &(*state)->gwy.addr,
+					    (*state)->gwy.port, &uh.uh_sum,
+					    pd2.ip_sum, icmpsum,
+					    pd->ip_sum, 1, pd2.af);
+				}
+				switch (pd2.af) {
+#ifdef INET
+				case AF_INET:
+					m_copyback(m, off, ICMP_MINLEN,
+					    (caddr_t)pd->hdr.icmp);
+					m_copyback(m, ipoff2, sizeof(h2),
+					    (caddr_t)&h2);
+					break;
+#endif /* INET */
+#ifdef INET6
+				case AF_INET6:
+					m_copyback(m, off, ICMP_MINLEN,
+					    (caddr_t)pd->hdr.icmp6);
+					m_copyback(m, ipoff2, sizeof(h2_6),
+					    (caddr_t)&h2_6);
+					break;
+#endif /* INET6 */
+				}
+				m_copyback(m, off2, sizeof(uh),
+				    (caddr_t)&uh);
+			}
+
+			return (PF_PASS);
+			break;
+		}
+#ifdef INET
+		case IPPROTO_ICMP: {
+			struct icmp iih;
+			struct pf_tree_node key;
+
+			if (!pf_pull_hdr(m, off2, &iih, ICMP_MINLEN,
+			    NULL, NULL, pd2.af)) {
+				DPFPRINTF(PF_DEBUG_MISC,
+				    ("pf: ICMP error message too short (icmp)\n"));
+				return (PF_DROP);
+			}
+
+			key.af = pd2.af;
+			key.proto = IPPROTO_ICMP;
+			PF_ACPY(&key.addr[0], pd2.dst, pd2.af);
+			key.port[0] = iih.icmp_id;
+			PF_ACPY(&key.addr[1], pd2.src, pd2.af);
+			key.port[1] = iih.icmp_id;
+
+			if (direction == PF_IN)
+				*state = pf_find_state(&tree_ext_gwy, &key);
+			else
+				*state = pf_find_state(&tree_lan_ext, &key);
+			if (*state == NULL)
+				return (PF_DROP);
+
+			if (STATE_TRANSLATE(*state)) {
+				if (direction == PF_IN) {
+					pf_change_icmp(pd2.src, &iih.icmp_id,
+					    daddr, &(*state)->lan.addr,
+					    (*state)->lan.port, NULL,
+					    pd2.ip_sum, icmpsum,
+					    pd->ip_sum, 0, AF_INET);
+				} else {
+					pf_change_icmp(pd2.dst, &iih.icmp_id,
+					    saddr, &(*state)->gwy.addr,
+					    (*state)->gwy.port, NULL,
+					    pd2.ip_sum, icmpsum,
+					    pd->ip_sum, 0, AF_INET);
+				}
+				m_copyback(m, off, ICMP_MINLEN,
+				    (caddr_t)pd->hdr.icmp);
+				m_copyback(m, ipoff2, sizeof(h2),
+				    (caddr_t)&h2);
+				m_copyback(m, off2, ICMP_MINLEN,
+				    (caddr_t)&iih);
+			}
+
+			return (PF_PASS);
+			break;
+		}
+#endif /* INET */
+#ifdef INET6
+		case IPPROTO_ICMPV6: {
+			struct icmp6_hdr iih;
+			struct pf_tree_node key;
+
+			if (!pf_pull_hdr(m, off2, &iih, ICMP_MINLEN,
+			    NULL, NULL, pd2.af)) {
+				DPFPRINTF(PF_DEBUG_MISC,
+				    ("pf: ICMP error message too short (icmp6)\n"));
+				return (PF_DROP);
+			}
+
+			key.af = pd2.af;
+			key.proto = IPPROTO_ICMPV6;
+			PF_ACPY(&key.addr[0], pd2.dst, pd2.af);
+			key.port[0] = iih.icmp6_id;
+			PF_ACPY(&key.addr[1], pd2.src, pd2.af);
+			key.port[1] = iih.icmp6_id;
+
+			if (direction == PF_IN)
+				*state = pf_find_state(&tree_ext_gwy, &key);
+			else
+				*state = pf_find_state(&tree_lan_ext, &key);
+			if (*state == NULL)
+				return (PF_DROP);
+
+			if (STATE_TRANSLATE(*state)) {
+				if (direction == PF_IN) {
+					pf_change_icmp(pd2.src, &iih.icmp6_id,
+					    daddr, &(*state)->lan.addr,
+					    (*state)->lan.port, NULL,
+					    pd2.ip_sum, icmpsum,
+					    pd->ip_sum, 0, AF_INET6);
+				} else {
+					pf_change_icmp(pd2.dst, &iih.icmp6_id,
+					    saddr, &(*state)->gwy.addr,
+					    (*state)->gwy.port, NULL,
+					    pd2.ip_sum, icmpsum,
+					    pd->ip_sum, 0, AF_INET6);
+				}
+				m_copyback(m, off, ICMP_MINLEN,
+				    (caddr_t)pd->hdr.icmp6);
+				m_copyback(m, ipoff2, sizeof(h2_6),
+				    (caddr_t)&h2_6);
+				m_copyback(m, off2, ICMP_MINLEN,
+				    (caddr_t)&iih);
+			}
+
+			return (PF_PASS);
+			break;
+		}
+#endif /* INET6 */
+		default:
+			DPFPRINTF(PF_DEBUG_MISC,
+			    ("pf: ICMP error message for bad proto\n"));
+			return (PF_DROP);
+		}
+
+	}
+}
+
+int
+pf_test_state_other(struct pf_state **state, int direction, struct ifnet *ifp,
+    struct pf_pdesc *pd)
+{
+	struct pf_state_peer *src, *dst;
+	struct pf_tree_node key;
+
+	key.af = pd->af;
+	key.proto = pd->proto;
+	PF_ACPY(&key.addr[0], pd->src, key.af);
+	PF_ACPY(&key.addr[1], pd->dst, key.af);
+	key.port[0] = 0;
+	key.port[1] = 0;
+
+	if (direction == PF_IN)
+		*state = pf_find_state(&tree_ext_gwy, &key);
+	else
+		*state = pf_find_state(&tree_lan_ext, &key);
+	if (*state == NULL)
+		return (PF_DROP);
+
+	if (direction == (*state)->direction) {
+		src = &(*state)->src;
+		dst = &(*state)->dst;
+	} else {
+		src = &(*state)->dst;
+		dst = &(*state)->src;
+	}
+
+	(*state)->packets++;
+	(*state)->bytes += pd->tot_len;
+
+	/* update states */
+	if (src->state < PFOTHERS_SINGLE)
+		src->state = PFOTHERS_SINGLE;
+	if (dst->state == PFOTHERS_SINGLE)
+		dst->state = PFOTHERS_MULTIPLE;
+
+	/* update expire time */
+	if (src->state == PFOTHERS_MULTIPLE && dst->state == PFOTHERS_MULTIPLE)
+		(*state)->expire = time.tv_sec +
+		    TIMEOUT((*state)->rule.ptr, PFTM_OTHER_MULTIPLE);
+	else
+		(*state)->expire = time.tv_sec +
+		    TIMEOUT((*state)->rule.ptr, PFTM_OTHER_SINGLE);
+
+	/* translate source/destination address, if necessary */
+	if (STATE_TRANSLATE(*state)) {
+		if (direction == PF_OUT)
+			switch (pd->af) {
+#ifdef INET
+			case AF_INET:
+				pf_change_a(&pd->src->v4.s_addr,
+				    pd->ip_sum, (*state)->gwy.addr.v4.s_addr, 0);
+				break;
+#endif /* INET */
+#ifdef INET6
+			case AF_INET6:
+				PF_ACPY(pd->src, &(*state)->gwy.addr, pd->af);
+				break;
+#endif /* INET6 */
+			}
+		else
+			switch (pd->af) {
+#ifdef INET
+			case AF_INET:
+				pf_change_a(&pd->dst->v4.s_addr,
+				    pd->ip_sum, (*state)->lan.addr.v4.s_addr, 0);
+				break;
+#endif /* INET */
+#ifdef INET6
+			case AF_INET6:
+				PF_ACPY(pd->dst, &(*state)->lan.addr, pd->af);
+				break;
+#endif /* INET6 */
+			}
+	}
+
+	if ((*state)->rule.ptr != NULL) {
+		(*state)->rule.ptr->packets++;
+		(*state)->rule.ptr->bytes += pd->tot_len;
+	}
+	return (PF_PASS);
+}
+
+/*
+ * ipoff and off are measured from the start of the mbuf chain.
+ * h must be at "ipoff" on the mbuf chain.
+ */
+void *
+pf_pull_hdr(struct mbuf *m, int off, void *p, int len,
+    u_short *actionp, u_short *reasonp, int af)
+{
+	switch (af) {
+#ifdef INET
+	case AF_INET: {
+		struct ip *h = mtod(m, struct ip *);
+		u_int16_t fragoff = (h->ip_off & IP_OFFMASK) << 3;
+
+		if (fragoff) {
+			if (fragoff >= len)
+				ACTION_SET(actionp, PF_PASS);
+			else {
+				ACTION_SET(actionp, PF_DROP);
+				REASON_SET(reasonp, PFRES_FRAG);
+			}
+			return (NULL);
+		}
+		if (m->m_pkthdr.len < off + len ||
+		    ntohs(h->ip_len) < off + len) {
+			ACTION_SET(actionp, PF_DROP);
+			REASON_SET(reasonp, PFRES_SHORT);
+			return (NULL);
+		}
+		break;
+	}
+#endif /* INET */
+#ifdef INET6
+	case AF_INET6: {
+		struct ip6_hdr *h = mtod(m, struct ip6_hdr *);
+
+		if (m->m_pkthdr.len < off + len ||
+		    (ntohs(h->ip6_plen) + sizeof(struct ip6_hdr)) < (unsigned)(off + len)) {
+			ACTION_SET(actionp, PF_DROP);
+			REASON_SET(reasonp, PFRES_SHORT);
+			return (NULL);
+		}
+		break;
+	}
+#endif /* INET6 */
+	}
+	m_copydata(m, off, len, p);
+	return (p);
+}
+
+int
+pf_routable(struct pf_addr *addr, int af)
+{
+	struct sockaddr_in *dst;
+	struct route ro;
+	int ret = 0;
+
+	bzero(&ro, sizeof(ro));
+	dst = satosin(&ro.ro_dst);
+	dst->sin_family = af;
+	dst->sin_len = sizeof(*dst);
+	dst->sin_addr = addr->v4;
+	rtalloc(&ro);
+
+	if (ro.ro_rt != NULL) {
+		ret = 1;
+		RTFREE(ro.ro_rt);
+	}
+
+	return (ret);
+}
+
+#ifdef INET
+void
+pf_route(struct mbuf **m, struct pf_rule *r, int dir)
+{
+	struct mbuf *m0, *m1;
+	struct route iproute;
+	struct route *ro;
+	struct sockaddr_in *dst;
+	struct ip *ip;
+	struct ifnet *ifp = r->rt_ifp;
+	struct m_tag *mtag;
+	int hlen;
+	int error = 0;
+	int sw_csum;
+
+	if (r->rt == PF_DUPTO) {
+		m0 = m_dup(*m, M_NOWAIT);
+		if (m0 == NULL)
+			return;
+	} else {
+		if (r->direction != dir)
+			return;
+		m0 = *m;
+	}
+
+	ip = mtod(m0, struct ip *);
+	hlen = ip->ip_hl << 2;
+
+	ro = &iproute;
+	bzero((caddr_t)ro, sizeof(*ro));
+	dst = satosin(&ro->ro_dst);
+	dst->sin_family = AF_INET;
+	dst->sin_len = sizeof(*dst);
+	dst->sin_addr = ip->ip_dst;
+
+	if (r->rt == PF_FASTROUTE) {
+		rtalloc(ro);
+		if (ro->ro_rt == 0) {
+			ipstat.ips_noroute++;
+			goto bad;
+		}
+
+		ifp = ro->ro_rt->rt_ifp;
+		ro->ro_rt->rt_use++;
+
+		if (ro->ro_rt->rt_flags & RTF_GATEWAY)
+			dst = satosin(ro->ro_rt->rt_gateway);
+	} else {
+		if (!PF_AZERO(&r->rt_addr, AF_INET))
+			dst->sin_addr.s_addr = r->rt_addr.v4.s_addr;
+	}
+
+	if (ifp == NULL)
+		goto bad;
+
+	if (r->ifp != ifp) {
+		mtag = m_tag_find(m0, PACKET_TAG_PF_ROUTED, NULL);
+		if (mtag == NULL) {
+			if (pf_test(PF_OUT, ifp, &m0) != PF_PASS)
+				goto bad;
+			else if (m0 == NULL)
+				goto done;
+			else {
+				mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0,
+				    M_NOWAIT);
+				if (mtag == NULL)
+					goto bad;
+				m_tag_prepend(m0, mtag);
+			}
+		}
+	}
+
+        sw_csum = m0->m_pkthdr.csum_flags & ~ifp->if_hwassist;
+        m0->m_pkthdr.csum_flags &= ifp->if_hwassist;
+
+	/* Copied from ip_output. */
+	if ((u_int16_t)ip->ip_len <= ifp->if_mtu) {
+		ip->ip_len = htons((u_int16_t)ip->ip_len);
+		ip->ip_off = htons((u_int16_t)ip->ip_off);
+                ip->ip_sum = 0;
+                if (sw_csum & CSUM_DELAY_IP) {
+                        if (ip->ip_v == IPVERSION &&
+                            (ip->ip_hl << 2) == sizeof(*ip)) {
+                                ip->ip_sum = in_cksum_hdr(ip);
+                        } else {
+                                ip->ip_sum = in_cksum(m0, ip->ip_hl << 2);
+                        }
+                }
+		error = (*ifp->if_output)(ifp, m0, sintosa(dst), NULL);
+		goto done;
+	}
+
+	/*
+	 * Too large for interface; fragment if possible.
+	 * Must be able to put at least 8 bytes per fragment.
+	 */
+	if (ip->ip_off & IP_DF) {
+		ipstat.ips_cantfrag++;
+		if (r->rt != PF_DUPTO) {
+			icmp_error(m0, ICMP_UNREACH, ICMP_UNREACH_NEEDFRAG, 0,
+			    ifp);
+			goto done;
+		} else
+			goto bad;
+	}
+
+	m1 = m0;
+	error = ip_fragment(ip, &m0, ifp->if_mtu, ifp->if_hwassist, sw_csum);
+	if (error == EMSGSIZE)
+		goto bad;
+
+	for (m0 = m1; m0; m0 = m1) {
+		m1 = m0->m_nextpkt;
+		m0->m_nextpkt = 0;
+		if (error == 0)
+			error = (*ifp->if_output)(ifp, m0, sintosa(dst),
+			    NULL);
+		else
+			m_freem(m0);
+	}
+
+	if (error == 0)
+		ipstat.ips_fragmented++;
+
+done:
+	if (r->rt != PF_DUPTO)
+		*m = NULL;
+	if (ro == &iproute && ro->ro_rt)
+		RTFREE(ro->ro_rt);
+	return;
+
+bad:
+	m_freem(m0);
+	goto done;
+}
+#endif /* INET */
+
+#ifdef INET6
+void
+pf_route6(struct mbuf **m, struct pf_rule *r, int dir)
+{
+	struct mbuf *m0;
+	struct m_tag *mtag;
+	struct route_in6 ip6route;
+	struct route_in6 *ro;
+	struct sockaddr_in6 *dst;
+	struct ip6_hdr *ip6;
+	struct ifnet *ifp = r->rt_ifp;
+	int error = 0;
+
+	if (m == NULL)
+		return;
+
+	if (r->rt == PF_DUPTO) {
+		m0 = m_dup(*m, M_NOWAIT);
+		if (m0 == NULL)
+			return;
+	} else {
+		if (r->direction != dir)
+			return;
+		m0 = *m;
+	}
+
+	ip6 = mtod(m0, struct ip6_hdr *);
+
+	ro = &ip6route;
+	bzero((caddr_t)ro, sizeof(*ro));
+	dst = (struct sockaddr_in6 *)&ro->ro_dst;
+	dst->sin6_family = AF_INET6;
+	dst->sin6_len = sizeof(*dst);
+	dst->sin6_addr = ip6->ip6_dst;
+
+	if (!PF_AZERO(&r->rt_addr, AF_INET6))
+		dst->sin6_addr = r->rt_addr.v6;
+
+	/* Cheat. */
+	if (r->rt == PF_FASTROUTE) {
+		mtag = m_tag_get(PACKET_TAG_PF_GENERATED, 0, M_NOWAIT);
+		if (mtag == NULL)
+			goto bad;
+		m_tag_prepend(m0, mtag);
+		ip6_output(m0, NULL, NULL, NULL, NULL, NULL, NULL);
+		return;
+	}
+
+	if (ifp == NULL)
+		goto bad;
+
+	if (r->ifp != ifp) {
+		mtag = m_tag_find(m0, PACKET_TAG_PF_ROUTED, NULL);
+		if (mtag == NULL) {
+			if (pf_test(PF_OUT, ifp, &m0) != PF_PASS)
+				goto bad;
+			else if (m0 == NULL)
+				goto done;
+			else {
+				mtag = m_tag_get(PACKET_TAG_PF_ROUTED, 0,
+				    M_NOWAIT);
+				if (mtag == NULL)
+					goto bad;
+				m_tag_prepend(m0, mtag);
+			}
+		}
+	}
+
+	/*
+	 * If the packet is too large for the outgoing interface,
+	 * send back an icmp6 error.
+	 */
+	if (m0->m_pkthdr.len <= ifp->if_mtu) {
+		error = (*ifp->if_output)(ifp, m0, (struct sockaddr *)dst,
+		    NULL);
+	} else {
+		in6_ifstat_inc(ifp, ifs6_in_toobig);
+		if (r->rt != PF_DUPTO)
+			icmp6_error(m0, ICMP6_PACKET_TOO_BIG, 0, ifp->if_mtu);
+		else
+			goto bad;
+	}
+
+done:
+	if (r->rt != PF_DUPTO)
+		*m = NULL;
+	return;
+
+bad:
+	m_freem(m0);
+	goto done;
+}
+#endif /* INET6 */
+
+#ifdef INET
+int
+pf_test(int dir, struct ifnet *ifp, struct mbuf **m0)
+{
+	u_short action, reason = 0, log = 0;
+	struct mbuf *m = *m0;
+	struct ip *h = NULL;
+	struct pf_rule *r = NULL;
+	struct pf_state *s = NULL;
+	struct pf_pdesc pd;
+	int off;
+
+	if (!pf_status.running ||
+	    (m_tag_find(m, PACKET_TAG_PF_GENERATED, NULL) != NULL))
+		return (PF_PASS);
+
+#ifdef DIAGNOSTIC
+	if ((m->m_flags & M_PKTHDR) == 0)
+		panic("non-M_PKTHDR is passed to pf_test");
+#endif
+
+	if (m->m_pkthdr.len < sizeof(*h)) {
+		action = PF_DROP;
+		REASON_SET(&reason, PFRES_SHORT);
+		log = 1;
+		goto done;
+	}
+
+	/* We do IP header normalization and packet reassembly here */
+	if (pf_normalize_ip(m0, dir, ifp, &reason) != PF_PASS) {
+		ACTION_SET(&action, PF_DROP);
+		goto done;
+	}
+	m = *m0;
+	h = mtod(m, struct ip *);
+
+	off = h->ip_hl << 2;
+	if (off < sizeof(*h)) {
+		action = PF_DROP;
+		REASON_SET(&reason, PFRES_SHORT);
+		log = 1;
+		goto done;
+	}
+
+	pd.src = (struct pf_addr *)&h->ip_src;
+	pd.dst = (struct pf_addr *)&h->ip_dst;
+	pd.ip_sum = &h->ip_sum;
+	pd.proto = h->ip_p;
+	pd.af = AF_INET;
+	pd.tot_len = h->ip_len;
+
+	/* handle fragments that didn't get reassembled by normalization */
+	if (h->ip_off & (IP_MF | IP_OFFMASK)) {
+		action = pf_test_fragment(&r, dir, ifp, m, h, &pd);
+		goto done;
+	}
+
+	switch (h->ip_p) {
+
+	case IPPROTO_TCP: {
+		struct tcphdr th;
+		pd.hdr.tcp = &th;
+
+		if (!pf_pull_hdr(m, off, &th, sizeof(th),
+		    &action, &reason, AF_INET)) {
+			log = action != PF_PASS;
+			goto done;
+		}
+		pd.p_len = pd.tot_len - off - (th.th_off << 2);
+		action = pf_normalize_tcp(dir, ifp, m, 0, off, h, &pd);
+		if (action == PF_DROP)
+			break;
+		action = pf_test_state_tcp(&s, dir, ifp, m, 0, off, h, &pd);
+		if (action == PF_PASS) {
+			r = s->rule.ptr;
+			log = s->log;
+		} else if (s == NULL)
+			action = pf_test_tcp(&r, dir, ifp, m, 0, off, h, &pd);
+		break;
+	}
+
+	case IPPROTO_UDP: {
+		struct udphdr uh;
+		pd.hdr.udp = &uh;
+
+		if (!pf_pull_hdr(m, off, &uh, sizeof(uh),
+		    &action, &reason, AF_INET)) {
+			log = action != PF_PASS;
+			goto done;
+		}
+		action = pf_test_state_udp(&s, dir, ifp, m, 0, off, h, &pd);
+		if (action == PF_PASS) {
+			r = s->rule.ptr;
+			log = s->log;
+		} else if (s == NULL)
+			action = pf_test_udp(&r, dir, ifp, m, 0, off, h, &pd);
+		break;
+	}
+
+	case IPPROTO_ICMP: {
+		struct icmp ih;
+		pd.hdr.icmp = &ih;
+
+		if (!pf_pull_hdr(m, off, &ih, ICMP_MINLEN,
+		    &action, &reason, AF_INET)) {
+			log = action != PF_PASS;
+			goto done;
+		}
+		action = pf_test_state_icmp(&s, dir, ifp, m, 0, off, h, &pd);
+		if (action == PF_PASS) {
+			r = s->rule.ptr;
+			if (r != NULL) {
+				r->packets++;
+				r->bytes += h->ip_len;
+			}
+			log = s->log;
+		} else if (s == NULL)
+			action = pf_test_icmp(&r, dir, ifp, m, 0, off, h, &pd);
+		break;
+	}
+
+	default:
+		action = pf_test_state_other(&s, dir, ifp, &pd);
+		if (action == PF_PASS) {
+			r = s->rule.ptr;
+			log = s->log;
+		} else if (s == NULL)
+			action = pf_test_other(&r, dir, ifp, m, h, &pd);
+		break;
+	}
+
+	if (ifp == status_ifp) {
+		pf_status.bcounters[0][dir] += pd.tot_len;
+		pf_status.pcounters[0][dir][action]++;
+	}
+
+done:
+	if (action != PF_DROP && h->ip_hl > 5 &&
+	    !((s && s->allow_opts) || (r && r->allow_opts))) {
+		action = PF_DROP;
+		REASON_SET(&reason, PFRES_SHORT);
+		log = 1;
+		DPFPRINTF(PF_DEBUG_MISC,
+		    ("pf: dropping packet with ip options\n"));
+	}
+
+	if (log) {
+		if (r == NULL) {
+			struct pf_rule r0;
+			r0.ifp = ifp;
+			r0.action = action;
+			r0.nr = -1;
+			PFLOG_PACKET(ifp, h, m, AF_INET, dir, reason, &r0);
+		} else
+			PFLOG_PACKET(ifp, h, m, AF_INET, dir, reason, r);
+	}
+
+	/* pf_route can free the mbuf causing *m0 to become NULL */
+	if (r && r->rt)
+		pf_route(m0, r, dir);
+
+	return (action);
+}
+#endif /* INET */ 
+
+#ifdef INET6
+int
+pf_test6(int dir, struct ifnet *ifp, struct mbuf **m0)
+{
+	u_short action, reason = 0, log = 0;
+	struct mbuf *m = *m0;
+	struct ip6_hdr *h;
+	struct pf_rule *r = NULL;
+	struct pf_state *s = NULL;
+	struct pf_pdesc pd;
+	int off, terminal = 0;
+
+	if (!pf_status.running ||
+	    (m_tag_find(m, PACKET_TAG_PF_GENERATED, NULL) != NULL))
+		return (PF_PASS);
+
+#ifdef DIAGNOSTIC
+	if ((m->m_flags & M_PKTHDR) == 0)
+		panic("non-M_PKTHDR is passed to pf_test");
+#endif
+
+	if (m->m_pkthdr.len < sizeof(*h)) {
+		action = PF_DROP;
+		REASON_SET(&reason, PFRES_SHORT);
+		log = 1;
+		goto done;
+	}
+
+	m = *m0;
+	h = mtod(m, struct ip6_hdr *);
+
+	pd.src = (struct pf_addr *)&h->ip6_src;
+	pd.dst = (struct pf_addr *)&h->ip6_dst;
+	pd.ip_sum = NULL;
+	pd.af = AF_INET6;
+	pd.tot_len = ntohs(h->ip6_plen) + sizeof(struct ip6_hdr);
+
+	off = ((caddr_t)h - m->m_data) + sizeof(struct ip6_hdr);
+	pd.proto = h->ip6_nxt;
+	do {
+		switch (pd.proto) {
+		case IPPROTO_FRAGMENT:
+			action = pf_test_fragment(&r, dir, ifp, m, h, &pd);
+			if (action == PF_DROP)
+				REASON_SET(&reason, PFRES_FRAG);
+			goto done;
+		case IPPROTO_AH:
+		case IPPROTO_HOPOPTS:
+		case IPPROTO_ROUTING:
+		case IPPROTO_DSTOPTS: {
+			/* get next header and header length */
+			struct ip6_ext opt6;
+
+			if (!pf_pull_hdr(m, off, &opt6, sizeof(opt6),
+			    NULL, NULL, pd.af)) {
+				DPFPRINTF(PF_DEBUG_MISC,
+				    ("pf: IPv6 short opt\n"));
+				action = PF_DROP;
+				REASON_SET(&reason, PFRES_SHORT);
+				log = 1;
+				goto done;
+			}
+			if (pd.proto == IPPROTO_AH)
+				off += (opt6.ip6e_len + 2) * 4;
+			else
+				off += (opt6.ip6e_len + 1) * 8;
+			pd.proto = opt6.ip6e_nxt;
+			/* goto the next header */
+			break;
+		}
+		default:
+			terminal++;
+			break;
+		}
+	} while (!terminal);
+
+	switch (pd.proto) {
+
+	case IPPROTO_TCP: {
+		struct tcphdr th;
+		pd.hdr.tcp = &th;
+
+		if (!pf_pull_hdr(m, off, &th, sizeof(th),
+		    &action, &reason, AF_INET6)) {
+			log = action != PF_PASS;
+			goto done;
+		}
+		pd.p_len = pd.tot_len - off - (th.th_off << 2);
+		action = pf_normalize_tcp(dir, ifp, m, 0, off, h, &pd);
+		if (action == PF_DROP)
+			break;
+		action = pf_test_state_tcp(&s, dir, ifp, m, 0, off, h, &pd);
+		if (action == PF_PASS) {
+			r = s->rule.ptr;
+			log = s->log;
+		} else if (s == NULL)
+			action = pf_test_tcp(&r, dir, ifp, m, 0, off, h, &pd);
+		break;
+	}
+
+	case IPPROTO_UDP: {
+		struct udphdr uh;
+		pd.hdr.udp = &uh;
+
+		if (!pf_pull_hdr(m, off, &uh, sizeof(uh),
+		    &action, &reason, AF_INET6)) {
+			log = action != PF_PASS;
+			goto done;
+		}
+		action = pf_test_state_udp(&s, dir, ifp, m, 0, off, h, &pd);
+		if (action == PF_PASS) {
+			r = s->rule.ptr;
+			log = s->log;
+		} else if (s == NULL)
+			action = pf_test_udp(&r, dir, ifp, m, 0, off, h, &pd);
+		break;
+	}
+
+	case IPPROTO_ICMPV6: {
+		struct icmp6_hdr ih;
+		pd.hdr.icmp6 = &ih;
+
+		if (!pf_pull_hdr(m, off, &ih, sizeof(ih),
+		    &action, &reason, AF_INET6)) {
+			log = action != PF_PASS;
+			goto done;
+		}
+		action = pf_test_state_icmp(&s, dir, ifp, m, 0, off, h, &pd);
+		if (action == PF_PASS) {
+			r = s->rule.ptr;
+			if (r != NULL) {
+				r->packets++;
+				r->bytes += h->ip6_plen;
+			}
+			log = s->log;
+		} else if (s == NULL)
+			action = pf_test_icmp(&r, dir, ifp, m, 0, off, h, &pd);
+		break;
+	}
+
+	default:
+		action = pf_test_other(&r, dir, ifp, m, h, &pd);
+		break;
+	}
+
+	if (ifp == status_ifp) {
+		pf_status.bcounters[1][dir] += pd.tot_len;
+		pf_status.pcounters[1][dir][action]++;
+	}
+
+done:
+	/* XXX handle IPv6 options, if not allowed. not implemented. */
+
+	if (log) {
+		if (r == NULL) {
+			struct pf_rule r0;
+			r0.ifp = ifp;
+			r0.action = action;
+			r0.nr = -1;
+			PFLOG_PACKET(ifp, h, m, AF_INET6, dir, reason, &r0);
+		} else
+			PFLOG_PACKET(ifp, h, m, AF_INET6, dir, reason, r);
+	}
+
+	/* pf_route6 can free the mbuf causing *m0 to become NULL */
+	if (r && r->rt)
+		pf_route6(m0, r, dir);
+
+	return (action);
+}
+#endif /* INET6 */
diff -Nur /usr/src/sys.orig/net/pf_ioctl.c /usr/src/sys/net/pf_ioctl.c
--- /usr/src/sys.orig/net/pf_ioctl.c	Thu Jan  1 08:00:00 1970
+++ /usr/src/sys/net/pf_ioctl.c	Wed Jul  9 22:33:22 2025
@@ -0,0 +1,1536 @@
+/*	$OpenBSD: pf_ioctl.c,v 1.8 2002/08/12 16:41:25 dhartmei Exp $ */
+
+/*
+ * Copyright (c) 2001 Daniel Hartmeier
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *    - Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    - Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Effort sponsored in part by the Defense Advanced Research Projects
+ * Agency (DARPA) and Air Force Research Laboratory, Air Force
+ * Materiel Command, USAF, under agreement number F30602-01-2-0537.
+ *
+ */
+
+#include "opt_inet.h"
+#include "opt_inet6.h"
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/libkern.h>
+#include <sys/mbuf.h>
+#include <sys/filio.h>
+#include <sys/fcntl.h>
+#include <sys/socket.h>
+#include <sys/socketvar.h>
+#include <sys/kernel.h>
+#include <sys/time.h>
+#include <sys/callout.h>
+#include <sys/malloc.h>
+#include <sys/conf.h>
+
+#include <net/if.h>
+#include <net/if_types.h>
+#include <net/route.h>
+
+#include <netinet/in.h>
+#include <netinet/in_var.h>
+#include <netinet/in_systm.h>
+#include <netinet/ip.h>
+#include <netinet/ip_var.h>
+
+#include <net/pfvar.h>
+
+#ifdef INET6
+#include <netinet/ip6.h>
+#include <netinet/in_pcb.h>
+#endif /* INET6 */
+
+void			 pfattach(int);
+int			 pfopen(dev_t, int, int, struct proc *);
+int			 pfclose(dev_t, int, int, struct proc *);
+int			 pfioctl(dev_t, u_long, caddr_t, int, struct proc *);
+
+PSEUDO_SET(pfattach, pf);
+
+#define CDEV_MAJOR 200
+static struct cdevsw pf_cdevsw = {
+	.d_open =	pfopen,
+	.d_close =	pfclose,
+	.d_read =	noread,
+	.d_write =	nowrite,
+	.d_ioctl =	pfioctl,
+	.d_poll =	nopoll,
+	.d_mmap =	nommap,
+	.d_strategy =	nostrategy,
+	.d_name =	"pf",
+	.d_maj =	CDEV_MAJOR,
+	.d_dump =	nodump,
+	.d_psize =	nopsize,
+	.d_flags =	0,
+	.d_kqfilter =	nokqfilter
+};
+
+extern struct timeval	time;
+extern struct callout	pf_expire_to;
+
+struct pf_rule		 pf_default_rule;
+struct pf_pool_limit	 pf_pool_limits[PF_LIMIT_MAX];
+
+pool_t			 pf_tree_pl, pf_rule_pl, pf_nat_pl, pf_sport_pl;
+pool_t			 pf_rdr_pl, pf_state_pl, pf_binat_pl, pf_addr_pl;
+
+#define DPFPRINTF(n, x) if (pf_status.debug >= (n)) printf x
+
+void
+pfattach(int num)
+{
+	u_int32_t *timeout = pf_default_rule.timeout;
+
+	pool_init(&pf_tree_pl, sizeof(struct pf_tree_node), 0, 0, 0, "pftrpl",
+	    NULL);
+	pool_init(&pf_rule_pl, sizeof(struct pf_rule), 0, 0, 0, "pfrulepl",
+	    &pool_allocator_nointr);
+	pool_init(&pf_nat_pl, sizeof(struct pf_nat), 0, 0, 0, "pfnatpl",
+	    &pool_allocator_nointr);
+	pool_init(&pf_binat_pl, sizeof(struct pf_binat), 0, 0, 0, "pfbinatpl",
+	    &pool_allocator_nointr);
+	pool_init(&pf_rdr_pl, sizeof(struct pf_rdr), 0, 0, 0, "pfrdrpl",
+	    &pool_allocator_nointr);
+	pool_init(&pf_state_pl, sizeof(struct pf_state), 0, 0, 0, "pfstatepl",
+	    NULL);
+	pool_init(&pf_addr_pl, sizeof(struct pf_addr_dyn), 0, 0, 0, "pfaddr",
+	    NULL);
+
+	TAILQ_INIT(&pf_rules[0]);
+	TAILQ_INIT(&pf_rules[1]);
+	TAILQ_INIT(&pf_nats[0]);
+	TAILQ_INIT(&pf_nats[1]);
+	TAILQ_INIT(&pf_binats[0]);
+	TAILQ_INIT(&pf_binats[1]);
+	TAILQ_INIT(&pf_rdrs[0]);
+	TAILQ_INIT(&pf_rdrs[1]);
+	pf_rules_active = &pf_rules[0];
+	pf_rules_inactive = &pf_rules[1];
+	pf_nats_active = &pf_nats[0];
+	pf_nats_inactive = &pf_nats[1];
+	pf_binats_active = &pf_binats[0];
+	pf_binats_inactive = &pf_binats[1];
+	pf_rdrs_active = &pf_rdrs[0];
+	pf_rdrs_inactive = &pf_rdrs[1];
+
+	callout_init(&pf_expire_to);
+	callout_reset(&pf_expire_to, timeout[PFTM_INTERVAL] * hz, pf_purge_timeout, &pf_expire_to);
+
+	pf_normalize_init();
+	pf_status.debug = PF_DEBUG_URGENT;
+
+	make_dev(&pf_cdevsw, 0, UID_ROOT, GID_WHEEL, 0600, "pf");
+}
+
+int
+pfopen(dev_t dev, int flags, int fmt, struct proc *p)
+{
+	if (minor(dev) >= 1)
+		return (ENXIO);
+	return (0);
+}
+
+int
+pfclose(dev_t dev, int flags, int fmt, struct proc *p)
+{
+	if (minor(dev) >= 1)
+		return (ENXIO);
+	return (0);
+}
+
+int
+pfioctl(dev_t dev, u_long cmd, caddr_t addr, int flags, struct proc *p)
+{
+	int error = 0;
+	int s;
+	struct timeval time;
+
+        time.tv_sec = time_second;
+
+	/* XXX keep in sync with switch() below */
+	if (securelevel > 1)
+		switch (cmd) {
+		case DIOCGETRULES:
+		case DIOCGETRULE:
+		case DIOCGETNATS:
+		case DIOCGETNAT:
+		case DIOCGETBINATS:
+		case DIOCGETBINAT:
+		case DIOCGETRDRS:
+		case DIOCGETRDR:
+		case DIOCGETSTATE:
+		case DIOCSETSTATUSIF:
+		case DIOCGETSTATUS:
+		case DIOCCLRSTATUS:
+		case DIOCNATLOOK:
+		case DIOCSETDEBUG:
+		case DIOCGETSTATES:
+		case DIOCGETTIMEOUT:
+		case DIOCCLRRULECTRS:
+		case DIOCGETLIMIT:
+			break;
+		default:
+			return (EPERM);
+		}
+
+	if (!(flags & FWRITE))
+		switch (cmd) {
+		case DIOCGETRULES:
+		case DIOCGETRULE:
+		case DIOCGETNATS:
+		case DIOCGETNAT:
+		case DIOCGETRDRS:
+		case DIOCGETRDR:
+		case DIOCGETSTATE:
+		case DIOCGETSTATUS:
+		case DIOCGETSTATES:
+		case DIOCGETTIMEOUT:
+		case DIOCGETBINATS:
+		case DIOCGETBINAT:
+		case DIOCGETLIMIT:
+			break;
+		default:
+			return (EACCES);
+		}
+
+	switch (cmd) {
+
+	case DIOCSTART:
+		if (pf_status.running)
+			error = EEXIST;
+		else {
+			u_int32_t states = pf_status.states;
+			bzero(&pf_status, sizeof(struct pf_status));
+			pf_status.running = 1;
+			pf_status.states = states;
+			pf_status.since = time.tv_sec;
+			if (status_ifp != NULL)
+                                snprintf(pf_status.ifname, IFNAMSIZ, "%s%d",
+                                    status_ifp->if_name, status_ifp->if_unit);
+			DPFPRINTF(PF_DEBUG_MISC, ("pf: started\n"));
+		}
+		break;
+
+	case DIOCSTOP:
+		if (!pf_status.running)
+			error = ENOENT;
+		else {
+			pf_status.running = 0;
+			DPFPRINTF(PF_DEBUG_MISC, ("pf: stopped\n"));
+		}
+		break;
+	
+	case DIOCBEGINRULES: {
+		u_int32_t *ticket = (u_int32_t *)addr;
+		struct pf_rule *rule;
+
+		while ((rule = TAILQ_FIRST(pf_rules_inactive)) != NULL) {
+			TAILQ_REMOVE(pf_rules_inactive, rule, entries);
+			pf_dynaddr_remove(&rule->src.addr);
+			pf_dynaddr_remove(&rule->dst.addr);
+			pool_put(&pf_rule_pl, rule);
+		}
+		*ticket = ++ticket_rules_inactive;
+		break;
+	}
+
+	case DIOCADDRULE: {
+		struct pfioc_rule *pr = (struct pfioc_rule *)addr;
+		struct pf_rule *rule, *tail;
+
+		if (pr->ticket != ticket_rules_inactive) {
+			error = EBUSY;
+			break;
+		}
+		rule = pool_get(&pf_rule_pl, PR_NOWAIT);
+		if (rule == NULL) {
+			error = ENOMEM;
+			break;
+		}
+		bcopy(&pr->rule, rule, sizeof(struct pf_rule));
+#ifndef INET
+		if (rule->af == AF_INET) {
+			pool_put(&pf_rule_pl, rule);
+			error = EAFNOSUPPORT;
+			break;
+		}
+#endif /* INET */
+#ifndef INET6
+		if (rule->af == AF_INET6) {
+			pool_put(&pf_rule_pl, rule);
+			error = EAFNOSUPPORT;
+			break;
+		}
+#endif /* INET6 */
+		tail = TAILQ_LAST(pf_rules_inactive, pf_rulequeue);
+		if (tail)
+			rule->nr = tail->nr + 1;
+		else
+			rule->nr = 0;
+		if (rule->ifname[0]) {
+			rule->ifp = ifunit(rule->ifname);
+			if (rule->ifp == NULL) {
+				pool_put(&pf_rule_pl, rule);
+				error = EINVAL;
+				break;
+			}
+		} else
+			rule->ifp = NULL;
+		if (rule->rt_ifname[0]) {
+			rule->rt_ifp = ifunit(rule->rt_ifname);
+			if (rule->rt_ifname == NULL) {
+				pool_put(&pf_rule_pl, rule);
+				error = EINVAL;
+				break;
+			}
+		} else
+			rule->rt_ifp = NULL;
+		if (pf_dynaddr_setup(&rule->src.addr, rule->af) ||
+		    pf_dynaddr_setup(&rule->dst.addr, rule->af)) {
+			pf_dynaddr_remove(&rule->src.addr);
+			pf_dynaddr_remove(&rule->dst.addr);
+			pool_put(&pf_rule_pl, rule);
+			error = EINVAL;
+			break;
+		}
+		rule->evaluations = rule->packets = rule->bytes = 0;
+		TAILQ_INSERT_TAIL(pf_rules_inactive, rule, entries);
+		break;
+	}
+
+	case DIOCCOMMITRULES: {
+		u_int32_t *ticket = (u_int32_t *)addr;
+		struct pf_rulequeue *old_rules;
+		struct pf_rule *rule;
+		struct pf_tree_node *n;
+
+		if (*ticket != ticket_rules_inactive) {
+			error = EBUSY;
+			break;
+		}
+
+		/* Swap rules, keep the old. */
+		s = splnet();
+
+		/*
+		 * Rules are about to get freed, clear rule pointers in states
+		 */
+		RB_FOREACH(n, pf_state_tree, &tree_ext_gwy)
+			n->state->rule.ptr = NULL;
+		old_rules = pf_rules_active;
+		pf_rules_active = pf_rules_inactive;
+		pf_rules_inactive = old_rules;
+		ticket_rules_active = ticket_rules_inactive;
+		pf_calc_skip_steps(pf_rules_active);
+		splx(s);
+
+		/* Purge the old rule list. */
+		while ((rule = TAILQ_FIRST(old_rules)) != NULL) {
+			TAILQ_REMOVE(old_rules, rule, entries);
+			pf_dynaddr_remove(&rule->src.addr);
+			pf_dynaddr_remove(&rule->dst.addr);
+			pool_put(&pf_rule_pl, rule);
+		}
+		break;
+	}
+
+	case DIOCGETRULES: {
+		struct pfioc_rule *pr = (struct pfioc_rule *)addr;
+		struct pf_rule *tail;
+
+		s = splnet();
+		tail = TAILQ_LAST(pf_rules_active, pf_rulequeue);
+		if (tail)
+			pr->nr = tail->nr + 1;
+		else
+			pr->nr = 0;
+		pr->ticket = ticket_rules_active;
+		splx(s);
+		break;
+	}
+
+	case DIOCGETRULE: {
+		struct pfioc_rule *pr = (struct pfioc_rule *)addr;
+		struct pf_rule *rule;
+
+		if (pr->ticket != ticket_rules_active) {
+			error = EBUSY;
+			break;
+		}
+		s = splnet();
+		rule = TAILQ_FIRST(pf_rules_active);
+		while ((rule != NULL) && (rule->nr != pr->nr))
+			rule = TAILQ_NEXT(rule, entries);
+		if (rule == NULL) {
+			error = EBUSY;
+			splx(s);
+			break;
+		}
+		bcopy(rule, &pr->rule, sizeof(struct pf_rule));
+		pf_dynaddr_copyout(&pr->rule.src.addr);
+		pf_dynaddr_copyout(&pr->rule.dst.addr);
+		splx(s);
+		break;
+	}
+
+	case DIOCCHANGERULE: {
+		struct pfioc_changerule *pcr = (struct pfioc_changerule *)addr;
+		struct pf_rule *oldrule = NULL, *newrule = NULL;
+		u_int32_t nr = 0;
+
+		if (pcr->action < PF_CHANGE_ADD_HEAD ||
+		    pcr->action > PF_CHANGE_REMOVE) {
+			error = EINVAL;
+			break;
+		}
+
+		if (pcr->action != PF_CHANGE_REMOVE) {
+			newrule = pool_get(&pf_rule_pl, PR_NOWAIT);
+			if (newrule == NULL) {
+				error = ENOMEM;
+				break;
+			}
+			bcopy(&pcr->newrule, newrule, sizeof(struct pf_rule));
+#ifndef INET
+			if (newrule->af == AF_INET) {
+				pool_put(&pf_rule_pl, newrule);
+				error = EAFNOSUPPORT;
+				break;
+			}
+#endif /* INET */
+#ifndef INET6
+			if (newrule->af == AF_INET6) {
+				pool_put(&pf_rule_pl, newrule);
+				error = EAFNOSUPPORT;
+				break;
+			}
+#endif /* INET6 */
+			if (newrule->ifname[0]) {
+				newrule->ifp = ifunit(newrule->ifname);
+				if (newrule->ifp == NULL) {
+					pool_put(&pf_rule_pl, newrule);
+					error = EINVAL;
+					break;
+				}
+			} else
+				newrule->ifp = NULL;
+			if (newrule->rt_ifname[0]) {
+				newrule->rt_ifp = ifunit(newrule->rt_ifname);
+				if (newrule->rt_ifname == NULL) {
+					pool_put(&pf_rule_pl, newrule);
+					error = EINVAL;
+					break;
+				}
+			} else
+				newrule->rt_ifp = NULL;
+			if (pf_dynaddr_setup(&newrule->src.addr, newrule->af) ||
+			    pf_dynaddr_setup(&newrule->dst.addr, newrule->af)) {
+				pf_dynaddr_remove(&newrule->src.addr);
+				pf_dynaddr_remove(&newrule->dst.addr);
+				pool_put(&pf_rule_pl, newrule);
+				error = EINVAL;
+				break;
+			}
+			newrule->evaluations = newrule->packets = 0;
+			newrule->bytes = 0;
+		}
+
+		s = splnet();
+
+		if (pcr->action == PF_CHANGE_ADD_HEAD)
+			oldrule = TAILQ_FIRST(pf_rules_active);
+		else if (pcr->action == PF_CHANGE_ADD_TAIL)
+			oldrule = TAILQ_LAST(pf_rules_active, pf_rulequeue);
+		else {
+			oldrule = TAILQ_FIRST(pf_rules_active);
+			while ((oldrule != NULL) && pf_compare_rules(oldrule,
+			    &pcr->oldrule))
+				oldrule = TAILQ_NEXT(oldrule, entries);
+			if (oldrule == NULL) {
+				error = EINVAL;
+				splx(s);
+				break;
+			}
+		}
+
+		if (pcr->action == PF_CHANGE_REMOVE) {
+			struct pf_tree_node *n;
+
+			RB_FOREACH(n, pf_state_tree, &tree_ext_gwy)
+				if (n->state->rule.ptr == oldrule)
+					n->state->rule.ptr = NULL;
+			TAILQ_REMOVE(pf_rules_active, oldrule, entries);
+			pf_dynaddr_remove(&oldrule->src.addr);
+			pf_dynaddr_remove(&oldrule->dst.addr);
+			pool_put(&pf_rule_pl, oldrule);
+		} else {
+			if (oldrule == NULL)
+				TAILQ_INSERT_TAIL(pf_rules_active, newrule,
+				    entries);
+			else if (pcr->action == PF_CHANGE_ADD_HEAD ||
+			    pcr->action == PF_CHANGE_ADD_BEFORE)
+				TAILQ_INSERT_BEFORE(oldrule, newrule, entries);
+			else
+				TAILQ_INSERT_AFTER(pf_rules_active, oldrule,
+				    newrule, entries);
+		}
+
+		TAILQ_FOREACH(oldrule, pf_rules_active, entries)
+			oldrule->nr = nr++;
+
+		pf_calc_skip_steps(pf_rules_active);
+
+		ticket_rules_active++;
+		splx(s);
+		break;
+	}
+
+	case DIOCBEGINNATS: {
+		u_int32_t *ticket = (u_int32_t *)addr;
+		struct pf_nat *nat;
+
+		while ((nat = TAILQ_FIRST(pf_nats_inactive)) != NULL) {
+			pf_dynaddr_remove(&nat->src.addr);
+			pf_dynaddr_remove(&nat->dst.addr);
+			pf_dynaddr_remove(&nat->raddr);
+			TAILQ_REMOVE(pf_nats_inactive, nat, entries);
+			pool_put(&pf_nat_pl, nat);
+		}
+		*ticket = ++ticket_nats_inactive;
+		break;
+	}
+
+	case DIOCADDNAT: {
+		struct pfioc_nat *pn = (struct pfioc_nat *)addr;
+		struct pf_nat *nat;
+
+		if (pn->ticket != ticket_nats_inactive) {
+			error = EBUSY;
+			break;
+		}
+		nat = pool_get(&pf_nat_pl, PR_NOWAIT);
+		if (nat == NULL) {
+			error = ENOMEM;
+			break;
+		}
+		bcopy(&pn->nat, nat, sizeof(struct pf_nat));
+#ifndef INET
+		if (nat->af == AF_INET) {
+			pool_put(&pf_nat_pl, nat);
+			error = EAFNOSUPPORT;
+			break;
+		}
+#endif /* INET */
+#ifndef INET6
+		if (nat->af == AF_INET6) {
+			pool_put(&pf_nat_pl, nat);
+			error = EAFNOSUPPORT;
+			break;
+		}
+#endif /* INET6 */
+		if (nat->ifname[0]) {
+			nat->ifp = ifunit(nat->ifname);
+			if (nat->ifp == NULL) {
+				pool_put(&pf_nat_pl, nat);
+				error = EINVAL;
+				break;
+			}
+		} else
+			nat->ifp = NULL;
+		if (pf_dynaddr_setup(&nat->src.addr, nat->af) ||
+		    pf_dynaddr_setup(&nat->dst.addr, nat->af) ||
+		    pf_dynaddr_setup(&nat->raddr, nat->af)) {
+			pf_dynaddr_remove(&nat->src.addr);
+			pf_dynaddr_remove(&nat->dst.addr);
+			pf_dynaddr_remove(&nat->raddr);
+			pool_put(&pf_nat_pl, nat);
+			error = EINVAL;
+			break;
+		}
+		TAILQ_INSERT_TAIL(pf_nats_inactive, nat, entries);
+		break;
+	}
+
+	case DIOCCOMMITNATS: {
+		u_int32_t *ticket = (u_int32_t *)addr;
+		struct pf_natqueue *old_nats;
+		struct pf_nat *nat;
+
+		if (*ticket != ticket_nats_inactive) {
+			error = EBUSY;
+			break;
+		}
+
+		/* Swap nats, keep the old. */
+		s = splnet();
+		old_nats = pf_nats_active;
+		pf_nats_active = pf_nats_inactive;
+		pf_nats_inactive = old_nats;
+		ticket_nats_active = ticket_nats_inactive;
+		splx(s);
+
+		/* Purge the old nat list */
+		while ((nat = TAILQ_FIRST(old_nats)) != NULL) {
+			pf_dynaddr_remove(&nat->src.addr);
+			pf_dynaddr_remove(&nat->dst.addr);
+			pf_dynaddr_remove(&nat->raddr);
+			TAILQ_REMOVE(old_nats, nat, entries);
+			pool_put(&pf_nat_pl, nat);
+		}
+		break;
+	}
+
+	case DIOCGETNATS: {
+		struct pfioc_nat *pn = (struct pfioc_nat *)addr;
+		struct pf_nat *nat;
+
+		pn->nr = 0;
+		s = splnet();
+		TAILQ_FOREACH(nat, pf_nats_active, entries)
+			pn->nr++;
+		pn->ticket = ticket_nats_active;
+		splx(s);
+		break;
+	}
+
+	case DIOCGETNAT: {
+		struct pfioc_nat *pn = (struct pfioc_nat *)addr;
+		struct pf_nat *nat;
+		u_int32_t nr;
+
+		if (pn->ticket != ticket_nats_active) {
+			error = EBUSY;
+			break;
+		}
+		nr = 0;
+		s = splnet();
+		nat = TAILQ_FIRST(pf_nats_active);
+		while ((nat != NULL) && (nr < pn->nr)) {
+			nat = TAILQ_NEXT(nat, entries);
+			nr++;
+		}
+		if (nat == NULL) {
+			error = EBUSY;
+			splx(s);
+			break;
+		}
+		bcopy(nat, &pn->nat, sizeof(struct pf_nat));
+		pf_dynaddr_copyout(&pn->nat.src.addr);
+		pf_dynaddr_copyout(&pn->nat.dst.addr);
+		pf_dynaddr_copyout(&pn->nat.raddr);
+		splx(s);
+		break;
+	}
+
+	case DIOCCHANGENAT: {
+		struct pfioc_changenat *pcn = (struct pfioc_changenat *)addr;
+		struct pf_nat *oldnat = NULL, *newnat = NULL;
+
+		if (pcn->action < PF_CHANGE_ADD_HEAD ||
+		    pcn->action > PF_CHANGE_REMOVE) {
+			error = EINVAL;
+			break;
+		}
+
+		if (pcn->action != PF_CHANGE_REMOVE) {
+			newnat = pool_get(&pf_nat_pl, PR_NOWAIT);
+			if (newnat == NULL) {
+				error = ENOMEM;
+				break;
+			}
+			bcopy(&pcn->newnat, newnat, sizeof(struct pf_nat));
+#ifndef INET
+			if (newnat->af == AF_INET) {
+				pool_put(&pf_nat_pl, newnat);
+				error = EAFNOSUPPORT;
+				break;
+			}
+#endif /* INET */
+#ifndef INET6
+			if (newnat->af == AF_INET6) {
+				pool_put(&pf_nat_pl, newnat);
+				error = EAFNOSUPPORT;
+				break;
+			}
+#endif /* INET6 */
+			if (newnat->ifname[0]) {
+				newnat->ifp = ifunit(newnat->ifname);
+				if (newnat->ifp == NULL) {
+					pool_put(&pf_nat_pl, newnat);
+					error = EINVAL;
+					break;
+				}
+			} else
+				newnat->ifp = NULL;
+			if (pf_dynaddr_setup(&newnat->src.addr, newnat->af) ||
+			    pf_dynaddr_setup(&newnat->dst.addr, newnat->af) ||
+			    pf_dynaddr_setup(&newnat->raddr, newnat->af)) {
+				pf_dynaddr_remove(&newnat->src.addr);
+				pf_dynaddr_remove(&newnat->dst.addr);
+				pf_dynaddr_remove(&newnat->raddr);
+				pool_put(&pf_nat_pl, newnat);
+				error = EINVAL;
+				break;
+			}
+		}
+
+		s = splnet();
+
+		if (pcn->action == PF_CHANGE_ADD_HEAD)
+			oldnat = TAILQ_FIRST(pf_nats_active);
+		else if (pcn->action == PF_CHANGE_ADD_TAIL)
+			oldnat = TAILQ_LAST(pf_nats_active, pf_natqueue);
+		else {
+			oldnat = TAILQ_FIRST(pf_nats_active);
+			while ((oldnat != NULL) && pf_compare_nats(oldnat,
+			    &pcn->oldnat))
+				oldnat = TAILQ_NEXT(oldnat, entries);
+			if (oldnat == NULL) {
+				error = EINVAL;
+				splx(s);
+				break;
+			}
+		}
+
+		if (pcn->action == PF_CHANGE_REMOVE) {
+			pf_dynaddr_remove(&oldnat->src.addr);
+			pf_dynaddr_remove(&oldnat->dst.addr);
+			pf_dynaddr_remove(&oldnat->raddr);
+			TAILQ_REMOVE(pf_nats_active, oldnat, entries);
+			pool_put(&pf_nat_pl, oldnat);
+		} else {
+			if (oldnat == NULL)
+				TAILQ_INSERT_TAIL(pf_nats_active, newnat,
+				    entries);
+			else if (pcn->action == PF_CHANGE_ADD_HEAD ||
+			    pcn->action == PF_CHANGE_ADD_BEFORE)
+				TAILQ_INSERT_BEFORE(oldnat, newnat, entries);
+			else
+				TAILQ_INSERT_AFTER(pf_nats_active, oldnat,
+				    newnat, entries);
+		}
+
+		ticket_nats_active++;
+		splx(s);
+		break;
+	}
+
+	case DIOCBEGINBINATS: {
+		u_int32_t *ticket = (u_int32_t *)addr;
+		struct pf_binat *binat;
+
+		while ((binat = TAILQ_FIRST(pf_binats_inactive)) != NULL) {
+			TAILQ_REMOVE(pf_binats_inactive, binat, entries);
+			pf_dynaddr_remove(&binat->saddr);
+			pf_dynaddr_remove(&binat->daddr);
+			pf_dynaddr_remove(&binat->raddr);
+			pool_put(&pf_binat_pl, binat);
+		}
+		*ticket = ++ticket_binats_inactive;
+		break;
+	}
+
+	case DIOCADDBINAT: {
+		struct pfioc_binat *pb = (struct pfioc_binat *)addr;
+		struct pf_binat *binat;
+
+		if (pb->ticket != ticket_binats_inactive) {
+			error = EBUSY;
+			break;
+		}
+		binat = pool_get(&pf_binat_pl, PR_NOWAIT);
+		if (binat == NULL) {
+			error = ENOMEM;
+			break;
+		}
+		bcopy(&pb->binat, binat, sizeof(struct pf_binat));
+#ifndef INET
+		if (binat->af == AF_INET) {
+			pool_put(&pf_binat_pl, binat);
+			error = EAFNOSUPPORT;
+			break;
+		}
+#endif /* INET */
+#ifndef INET6
+		if (binat->af == AF_INET6) {
+			pool_put(&pf_binat_pl, binat);
+			error = EAFNOSUPPORT;
+			break;
+		}
+#endif /* INET6 */
+		if (binat->ifname[0]) {
+			binat->ifp = ifunit(binat->ifname);
+			if (binat->ifp == NULL) {
+				pool_put(&pf_binat_pl, binat);
+				error = EINVAL;
+				break;
+			}
+		} else
+			binat->ifp = NULL;
+		if (pf_dynaddr_setup(&binat->saddr, binat->af) ||
+		    pf_dynaddr_setup(&binat->daddr, binat->af) ||
+		    pf_dynaddr_setup(&binat->raddr, binat->af)) {
+			pf_dynaddr_remove(&binat->saddr);
+			pf_dynaddr_remove(&binat->daddr);
+			pf_dynaddr_remove(&binat->raddr);
+			pool_put(&pf_binat_pl, binat);
+			error = EINVAL;
+			break;
+		}
+		TAILQ_INSERT_TAIL(pf_binats_inactive, binat, entries);
+		break;
+	}
+
+	case DIOCCOMMITBINATS: {
+		u_int32_t *ticket = (u_int32_t *)addr;
+		struct pf_binatqueue *old_binats;
+		struct pf_binat *binat;
+
+		if (*ticket != ticket_binats_inactive) {
+			error = EBUSY;
+			break;
+		}
+
+		/* Swap binats, keep the old. */
+		s = splnet();
+		old_binats = pf_binats_active;
+		pf_binats_active = pf_binats_inactive;
+		pf_binats_inactive = old_binats;
+		ticket_binats_active = ticket_binats_inactive;
+		splx(s);
+
+		/* Purge the old binat list */
+		while ((binat = TAILQ_FIRST(old_binats)) != NULL) {
+			TAILQ_REMOVE(old_binats, binat, entries);
+			pf_dynaddr_remove(&binat->saddr);
+			pf_dynaddr_remove(&binat->daddr);
+			pf_dynaddr_remove(&binat->raddr);
+			pool_put(&pf_binat_pl, binat);
+		}
+		break;
+	}
+
+	case DIOCGETBINATS: {
+		struct pfioc_binat *pb = (struct pfioc_binat *)addr;
+		struct pf_binat *binat;
+
+		pb->nr = 0;
+		s = splnet();
+		TAILQ_FOREACH(binat, pf_binats_active, entries)
+			pb->nr++;
+		pb->ticket = ticket_binats_active;
+		splx(s);
+		break;
+	}
+
+	case DIOCGETBINAT: {
+		struct pfioc_binat *pb = (struct pfioc_binat *)addr;
+		struct pf_binat *binat;
+		u_int32_t nr;
+
+		if (pb->ticket != ticket_binats_active) {
+			error = EBUSY;
+			break;
+		}
+		nr = 0;
+		s = splnet();
+		binat = TAILQ_FIRST(pf_binats_active);
+		while ((binat != NULL) && (nr < pb->nr)) {
+			binat = TAILQ_NEXT(binat, entries);
+			nr++;
+		}
+		if (binat == NULL) {
+			error = EBUSY;
+			splx(s);
+			break;
+		}
+		bcopy(binat, &pb->binat, sizeof(struct pf_binat));
+		pf_dynaddr_copyout(&pb->binat.saddr);
+		pf_dynaddr_copyout(&pb->binat.daddr);
+		pf_dynaddr_copyout(&pb->binat.raddr);
+		splx(s);
+		break;
+	}
+
+	case DIOCCHANGEBINAT: {
+		struct pfioc_changebinat *pcn = (struct pfioc_changebinat *)addr;
+		struct pf_binat *oldbinat = NULL, *newbinat = NULL;
+
+		if (pcn->action < PF_CHANGE_ADD_HEAD ||
+		    pcn->action > PF_CHANGE_REMOVE) {
+			error = EINVAL;
+			break;
+		}
+
+		if (pcn->action != PF_CHANGE_REMOVE) {
+			newbinat = pool_get(&pf_binat_pl, PR_NOWAIT);
+			if (newbinat == NULL) {
+				error = ENOMEM;
+				break;
+			}
+			bcopy(&pcn->newbinat, newbinat,
+				sizeof(struct pf_binat));
+#ifndef INET
+			if (newbinat->af == AF_INET) {
+				pool_put(&pf_binat_pl, newbinat);
+				error = EAFNOSUPPORT;
+				break;
+			}
+#endif /* INET */
+#ifndef INET6
+			if (newbinat->af == AF_INET6) {
+				pool_put(&pf_binat_pl, newbinat);
+				error = EAFNOSUPPORT;
+				break;
+			}
+#endif /* INET6 */
+			if (newbinat->ifname[0]) {
+				newbinat->ifp = ifunit(newbinat->ifname);
+				if (newbinat->ifp == NULL) {
+					pool_put(&pf_binat_pl, newbinat);
+					error = EINVAL;
+					break;
+				}
+			} else
+				newbinat->ifp = NULL;
+			if (pf_dynaddr_setup(&newbinat->saddr, newbinat->af) ||
+			    pf_dynaddr_setup(&newbinat->daddr, newbinat->af) ||
+			    pf_dynaddr_setup(&newbinat->raddr, newbinat->af)) {
+				pf_dynaddr_remove(&newbinat->saddr);
+				pf_dynaddr_remove(&newbinat->daddr);
+				pf_dynaddr_remove(&newbinat->raddr);
+				pool_put(&pf_binat_pl, newbinat);
+				error = EINVAL;
+				break;
+			}
+		}
+
+		s = splnet();
+
+		if (pcn->action == PF_CHANGE_ADD_HEAD)
+			oldbinat = TAILQ_FIRST(pf_binats_active);
+		else if (pcn->action == PF_CHANGE_ADD_TAIL)
+			oldbinat = TAILQ_LAST(pf_binats_active, pf_binatqueue);
+		else {
+			oldbinat = TAILQ_FIRST(pf_binats_active);
+			while ((oldbinat != NULL) && pf_compare_binats(oldbinat,
+			    &pcn->oldbinat))
+				oldbinat = TAILQ_NEXT(oldbinat, entries);
+			if (oldbinat == NULL) {
+				error = EINVAL;
+				splx(s);
+				break;
+			}
+		}
+
+		if (pcn->action == PF_CHANGE_REMOVE) {
+			TAILQ_REMOVE(pf_binats_active, oldbinat, entries);
+			pf_dynaddr_remove(&oldbinat->saddr);
+			pf_dynaddr_remove(&oldbinat->daddr);
+			pf_dynaddr_remove(&oldbinat->raddr);
+			pool_put(&pf_binat_pl, oldbinat);
+		} else {
+			if (oldbinat == NULL)
+				TAILQ_INSERT_TAIL(pf_binats_active, newbinat,
+				    entries);
+			else if (pcn->action == PF_CHANGE_ADD_HEAD ||
+			    pcn->action == PF_CHANGE_ADD_BEFORE)
+				TAILQ_INSERT_BEFORE(oldbinat, newbinat,
+				    entries);
+			else
+				TAILQ_INSERT_AFTER(pf_binats_active, oldbinat,
+				    newbinat, entries);
+		}
+
+		ticket_binats_active++;
+		splx(s);
+		break;
+	}
+
+	case DIOCBEGINRDRS: {
+		u_int32_t *ticket = (u_int32_t *)addr;
+		struct pf_rdr *rdr;
+
+		while ((rdr = TAILQ_FIRST(pf_rdrs_inactive)) != NULL) {
+			TAILQ_REMOVE(pf_rdrs_inactive, rdr, entries);
+			pf_dynaddr_remove(&rdr->saddr);
+			pf_dynaddr_remove(&rdr->daddr);
+			pf_dynaddr_remove(&rdr->raddr);
+			pool_put(&pf_rdr_pl, rdr);
+		}
+		*ticket = ++ticket_rdrs_inactive;
+		break;
+	}
+
+	case DIOCADDRDR: {
+		struct pfioc_rdr *pr = (struct pfioc_rdr *)addr;
+		struct pf_rdr *rdr;
+
+		if (pr->ticket != ticket_rdrs_inactive) {
+			error = EBUSY;
+			break;
+		}
+		rdr = pool_get(&pf_rdr_pl, PR_NOWAIT);
+		if (rdr == NULL) {
+			error = ENOMEM;
+			break;
+		}
+		bcopy(&pr->rdr, rdr, sizeof(struct pf_rdr));
+#ifndef INET
+		if (rdr->af == AF_INET) {
+			pool_put(&pf_rdr_pl, rdr);
+			error = EAFNOSUPPORT;
+			break;
+		}
+#endif /* INET */
+#ifndef INET6
+		if (rdr->af == AF_INET6) {
+			pool_put(&pf_rdr_pl, rdr);
+			error = EAFNOSUPPORT;
+			break;
+		}
+#endif /* INET6 */
+		if (rdr->ifname[0]) {
+			rdr->ifp = ifunit(rdr->ifname);
+			if (rdr->ifp == NULL) {
+				pool_put(&pf_rdr_pl, rdr);
+				error = EINVAL;
+				break;
+			}
+		} else
+			rdr->ifp = NULL;
+		if (pf_dynaddr_setup(&rdr->saddr, rdr->af) ||
+		    pf_dynaddr_setup(&rdr->daddr, rdr->af) ||
+		    pf_dynaddr_setup(&rdr->raddr, rdr->af)) {
+			pf_dynaddr_remove(&rdr->saddr);
+			pf_dynaddr_remove(&rdr->daddr);
+			pf_dynaddr_remove(&rdr->raddr);
+			pool_put(&pf_rdr_pl, rdr);
+			error = EINVAL;
+			break;
+		}
+		TAILQ_INSERT_TAIL(pf_rdrs_inactive, rdr, entries);
+		break;
+	}
+
+	case DIOCCOMMITRDRS: {
+		u_int32_t *ticket = (u_int32_t *)addr;
+		struct pf_rdrqueue *old_rdrs;
+		struct pf_rdr *rdr;
+
+		if (*ticket != ticket_rdrs_inactive) {
+			error = EBUSY;
+			break;
+		}
+
+		/* Swap rdrs, keep the old. */
+		s = splnet();
+		old_rdrs = pf_rdrs_active;
+		pf_rdrs_active = pf_rdrs_inactive;
+		pf_rdrs_inactive = old_rdrs;
+		ticket_rdrs_active = ticket_rdrs_inactive;
+		splx(s);
+
+		/* Purge the old rdr list */
+		while ((rdr = TAILQ_FIRST(old_rdrs)) != NULL) {
+			TAILQ_REMOVE(old_rdrs, rdr, entries);
+			pf_dynaddr_remove(&rdr->saddr);
+			pf_dynaddr_remove(&rdr->daddr);
+			pf_dynaddr_remove(&rdr->raddr);
+			pool_put(&pf_rdr_pl, rdr);
+		}
+		break;
+	}
+
+	case DIOCGETRDRS: {
+		struct pfioc_rdr *pr = (struct pfioc_rdr *)addr;
+		struct pf_rdr *rdr;
+
+		pr->nr = 0;
+		s = splnet();
+		TAILQ_FOREACH(rdr, pf_rdrs_active, entries)
+			pr->nr++;
+		pr->ticket = ticket_rdrs_active;
+		splx(s);
+		break;
+	}
+
+	case DIOCGETRDR: {
+		struct pfioc_rdr *pr = (struct pfioc_rdr *)addr;
+		struct pf_rdr *rdr;
+		u_int32_t nr;
+
+		if (pr->ticket != ticket_rdrs_active) {
+			error = EBUSY;
+			break;
+		}
+		nr = 0;
+		s = splnet();
+		rdr = TAILQ_FIRST(pf_rdrs_active);
+		while ((rdr != NULL) && (nr < pr->nr)) {
+			rdr = TAILQ_NEXT(rdr, entries);
+			nr++;
+		}
+		if (rdr == NULL) {
+			error = EBUSY;
+			splx(s);
+			break;
+		}
+		bcopy(rdr, &pr->rdr, sizeof(struct pf_rdr));
+		pf_dynaddr_copyout(&pr->rdr.saddr);
+		pf_dynaddr_copyout(&pr->rdr.daddr);
+		pf_dynaddr_copyout(&pr->rdr.raddr);
+		splx(s);
+		break;
+	}
+
+	case DIOCCHANGERDR: {
+		struct pfioc_changerdr *pcn = (struct pfioc_changerdr *)addr;
+		struct pf_rdr *oldrdr = NULL, *newrdr = NULL;
+
+		if (pcn->action < PF_CHANGE_ADD_HEAD ||
+		    pcn->action > PF_CHANGE_REMOVE) {
+			error = EINVAL;
+			break;
+		}
+
+		if (pcn->action != PF_CHANGE_REMOVE) {
+			newrdr = pool_get(&pf_rdr_pl, PR_NOWAIT);
+			if (newrdr == NULL) {
+				error = ENOMEM;
+				break;
+			}
+			bcopy(&pcn->newrdr, newrdr, sizeof(struct pf_rdr));
+#ifndef INET
+			if (newrdr->af == AF_INET) {
+				pool_put(&pf_rdr_pl, newrdr);
+				error = EAFNOSUPPORT;
+				break;
+			}
+#endif /* INET */
+#ifndef INET6
+			if (newrdr->af == AF_INET6) {
+				pool_put(&pf_rdr_pl, newrdr);
+				error = EAFNOSUPPORT;
+				break;
+			}
+#endif /* INET6 */
+			if (newrdr->ifname[0]) {
+				newrdr->ifp = ifunit(newrdr->ifname);
+				if (newrdr->ifp == NULL) {
+					pool_put(&pf_rdr_pl, newrdr);
+					error = EINVAL;
+					break;
+				}
+			} else
+				newrdr->ifp = NULL;
+			if (pf_dynaddr_setup(&newrdr->saddr, newrdr->af) ||
+			    pf_dynaddr_setup(&newrdr->daddr, newrdr->af) ||
+			    pf_dynaddr_setup(&newrdr->raddr, newrdr->af)) {
+				pf_dynaddr_remove(&newrdr->saddr);
+				pf_dynaddr_remove(&newrdr->daddr);
+				pf_dynaddr_remove(&newrdr->raddr);
+				pool_put(&pf_rdr_pl, newrdr);
+				error = EINVAL;
+				break;
+			}
+		}
+
+		s = splnet();
+
+		if (pcn->action == PF_CHANGE_ADD_HEAD)
+			oldrdr = TAILQ_FIRST(pf_rdrs_active);
+		else if (pcn->action == PF_CHANGE_ADD_TAIL)
+			oldrdr = TAILQ_LAST(pf_rdrs_active, pf_rdrqueue);
+		else {
+			oldrdr = TAILQ_FIRST(pf_rdrs_active);
+			while ((oldrdr != NULL) && pf_compare_rdrs(oldrdr,
+			    &pcn->oldrdr))
+				oldrdr = TAILQ_NEXT(oldrdr, entries);
+			if (oldrdr == NULL) {
+				error = EINVAL;
+				splx(s);
+				break;
+			}
+		}
+
+		if (pcn->action == PF_CHANGE_REMOVE) {
+			TAILQ_REMOVE(pf_rdrs_active, oldrdr, entries);
+			pf_dynaddr_remove(&oldrdr->saddr);
+			pf_dynaddr_remove(&oldrdr->daddr);
+			pf_dynaddr_remove(&oldrdr->raddr);
+			pool_put(&pf_rdr_pl, oldrdr);
+		} else {
+			if (oldrdr == NULL)
+				TAILQ_INSERT_TAIL(pf_rdrs_active, newrdr,
+				    entries);
+			else if (pcn->action == PF_CHANGE_ADD_HEAD ||
+			    pcn->action == PF_CHANGE_ADD_BEFORE)
+				TAILQ_INSERT_BEFORE(oldrdr, newrdr, entries);
+			else
+				TAILQ_INSERT_AFTER(pf_rdrs_active, oldrdr,
+				    newrdr, entries);
+		}
+
+		ticket_rdrs_active++;
+		splx(s);
+		break;
+	}
+
+	case DIOCCLRSTATES: {
+		struct pf_tree_node *n;
+
+		s = splnet();
+		RB_FOREACH(n, pf_state_tree, &tree_ext_gwy)
+			n->state->expire = 0;
+		pf_purge_expired_states();
+		pf_status.states = 0;
+		splx(s);
+		break;
+	}
+
+	case DIOCKILLSTATES: {
+		struct pf_tree_node *n;
+		struct pf_state *st;
+		struct pfioc_state_kill *psk =
+		    (struct pfioc_state_kill *)addr;
+		int killed = 0;
+
+		s = splnet();
+		RB_FOREACH(n, pf_state_tree, &tree_ext_gwy) {
+			st = n->state;
+			if ((!psk->psk_af || st->af == psk->psk_af) &&
+			    (!psk->psk_proto || psk->psk_proto == st->proto) &&
+			    PF_MATCHA(psk->psk_src.not, &psk->psk_src.addr.addr,
+			    &psk->psk_src.mask, &st->lan.addr, st->af) &&
+			    PF_MATCHA(psk->psk_dst.not, &psk->psk_dst.addr.addr,
+			    &psk->psk_dst.mask, &st->ext.addr, st->af) &&
+			    (psk->psk_src.port_op == 0 ||
+			    pf_match_port(psk->psk_src.port_op,
+			    psk->psk_src.port[0], psk->psk_src.port[1],
+			    st->lan.port)) &&
+			    (psk->psk_dst.port_op == 0 ||
+			    pf_match_port(psk->psk_dst.port_op,
+			    psk->psk_dst.port[0], psk->psk_dst.port[1],
+			    st->ext.port))) {
+				st->expire = 0;
+				killed++;
+			}
+		}
+		pf_purge_expired_states();
+		splx(s);
+		psk->psk_af = killed;
+		break;
+	}
+
+	case DIOCADDSTATE: {
+		struct pfioc_state *ps = (struct pfioc_state *)addr;
+		struct pf_state *state;
+
+		state = pool_get(&pf_state_pl, PR_NOWAIT);
+		if (state == NULL) {
+			error = ENOMEM;
+			break;
+		}
+		s = splnet();
+		bcopy(&ps->state, state, sizeof(struct pf_state));
+		state->rule.ptr = NULL;
+		state->creation = time.tv_sec;
+		state->expire += state->creation;
+		state->packets = 0;
+		state->bytes = 0;
+
+		if (pf_insert_state(state)) {
+			pool_put(&pf_state_pl, state);
+			error = ENOMEM;
+		}
+		splx(s);
+		break;
+	}
+
+	case DIOCGETSTATE: {
+		struct pfioc_state *ps = (struct pfioc_state *)addr;
+		struct pf_tree_node *n;
+		u_int32_t nr;
+		int secs;
+
+		nr = 0;
+		s = splnet();
+		RB_FOREACH(n, pf_state_tree, &tree_ext_gwy) {
+			if (nr >= ps->nr)
+				break;
+			nr++;
+		}
+		if (n == NULL) {
+			error = EBUSY;
+			splx(s);
+			break;
+		}
+		bcopy(n->state, &ps->state, sizeof(struct pf_state));
+		if (n->state->rule.ptr == NULL)
+			ps->state.rule.nr = -1;
+		else
+			ps->state.rule.nr = n->state->rule.ptr->nr;
+		splx(s);
+		secs = time.tv_sec;
+		ps->state.creation = secs - ps->state.creation;
+		if (ps->state.expire <= secs)
+			ps->state.expire = 0;
+		else
+			ps->state.expire -= secs;
+		break;
+	}
+
+	case DIOCGETSTATES: {
+		struct pfioc_states *ps = (struct pfioc_states *)addr;
+		struct pf_tree_node *n;
+		struct pf_state *p, pstore;
+		u_int32_t nr = 0;
+		int space = ps->ps_len;
+
+		if (space == 0) {
+			s = splnet();
+			RB_FOREACH(n, pf_state_tree, &tree_ext_gwy)
+				nr++;
+			splx(s);
+			ps->ps_len = sizeof(struct pf_state) * nr;
+			return (0);
+		}
+
+		s = splnet();
+		p = ps->ps_states;
+		RB_FOREACH(n, pf_state_tree, &tree_ext_gwy) {
+			int secs = time.tv_sec;
+
+			/* if ((nr + 1) * sizeof(*p) > ps->ps_len) */
+			if ((nr + 1) * sizeof(*p) > (unsigned)ps->ps_len)
+				break;
+
+			bcopy(n->state, &pstore, sizeof(pstore));
+			if (n->state->rule.ptr == NULL)
+				pstore.rule.nr = -1;
+			else
+				pstore.rule.nr = n->state->rule.ptr->nr;
+			pstore.creation = secs - pstore.creation;
+			if (pstore.expire <= secs)
+				pstore.expire = 0;
+			else
+				pstore.expire -= secs;
+			error = copyout(&pstore, p, sizeof(*p));
+			if (error) {
+				splx(s);
+				goto fail;
+			}
+			p++;
+			nr++;
+		}
+		ps->ps_len = sizeof(struct pf_state) * nr;
+		splx(s);
+		break;
+	}
+
+	case DIOCSETSTATUSIF: {
+		struct pfioc_if *pi = (struct pfioc_if *)addr;
+		struct ifnet *ifp;
+
+		if (pi->ifname[0] == 0) {
+			status_ifp = NULL;
+			bzero(pf_status.ifname, IFNAMSIZ);
+		} else
+			if ((ifp = ifunit(pi->ifname)) == NULL)
+				error = EINVAL;
+			else {
+				status_ifp = ifp;
+                                snprintf(pf_status.ifname, IFNAMSIZ, "%s%d",
+                                    status_ifp->if_name, status_ifp->if_unit);
+			}
+		break;
+	}
+
+	case DIOCGETSTATUS: {
+		struct pf_status *s = (struct pf_status *)addr;
+		bcopy(&pf_status, s, sizeof(struct pf_status));
+		break;
+	}
+
+	case DIOCCLRSTATUS: {
+		u_int32_t running = pf_status.running;
+		u_int32_t states = pf_status.states;
+		u_int32_t since = pf_status.since;
+		u_int32_t debug = pf_status.debug;
+
+		bzero(&pf_status, sizeof(struct pf_status));
+		pf_status.running = running;
+		pf_status.states = states;
+		pf_status.since = since;
+		pf_status.debug = debug;
+		if (status_ifp != NULL)
+			snprintf(pf_status.ifname, IFNAMSIZ, "%s%d",
+			    status_ifp->if_name, status_ifp->if_unit);
+		break;
+	}
+
+	case DIOCNATLOOK: {
+		struct pfioc_natlook *pnl = (struct pfioc_natlook *)addr;
+		struct pf_state *st;
+		struct pf_tree_node key;
+		int direction = pnl->direction;
+
+		key.af = pnl->af;
+		key.proto = pnl->proto;
+
+		/*
+		 * userland gives us source and dest of connetion, reverse
+		 * the lookup so we ask for what happens with the return
+		 * traffic, enabling us to find it in the state tree.
+		 */
+		PF_ACPY(&key.addr[1], &pnl->saddr, pnl->af);
+		key.port[1] = pnl->sport;
+		PF_ACPY(&key.addr[0], &pnl->daddr, pnl->af);
+		key.port[0] = pnl->dport;
+
+		if (!pnl->proto ||
+		    PF_AZERO(&pnl->saddr, pnl->af) ||
+		    PF_AZERO(&pnl->daddr, pnl->af) ||
+		    !pnl->dport || !pnl->sport)
+			error = EINVAL;
+		else {
+			s = splnet();
+			if (direction == PF_IN)
+				st = pf_find_state(&tree_ext_gwy, &key);
+			else
+				st = pf_find_state(&tree_lan_ext, &key);
+			if (st != NULL) {
+				if (direction  == PF_IN) {
+					PF_ACPY(&pnl->rsaddr, &st->lan.addr,
+					    st->af);
+					pnl->rsport = st->lan.port;
+					PF_ACPY(&pnl->rdaddr, &pnl->daddr,
+					    pnl->af);
+					pnl->rdport = pnl->dport;
+				} else {
+					PF_ACPY(&pnl->rdaddr, &st->gwy.addr,
+					    st->af);
+					pnl->rdport = st->gwy.port;
+					PF_ACPY(&pnl->rsaddr, &pnl->saddr,
+					    pnl->af);
+					pnl->rsport = pnl->sport;
+				}
+			} else
+				error = ENOENT;
+			splx(s);
+		}
+		break;
+	}
+
+	case DIOCSETTIMEOUT: {
+		struct pfioc_tm *pt = (struct pfioc_tm *)addr;
+		int old;
+
+		if (pt->timeout < 0 || pt->timeout >= PFTM_MAX ||
+		    pt->seconds < 0) {
+			error = EINVAL;
+			goto fail;
+		}
+		old = *pftm_timeouts[pt->timeout];
+		*pftm_timeouts[pt->timeout] = pt->seconds;
+		pt->seconds = old;
+		break;
+	}
+
+	case DIOCGETTIMEOUT: {
+		struct pfioc_tm *pt = (struct pfioc_tm *)addr;
+
+		if (pt->timeout < 0 || pt->timeout >= PFTM_MAX) {
+			error = EINVAL;
+			goto fail;
+		}
+		pt->seconds = *pftm_timeouts[pt->timeout];
+		break;
+	}
+
+	case DIOCGETLIMIT: {
+		struct pfioc_limit *pl = (struct pfioc_limit *)addr;
+
+		if (pl->index < 0 || pl->index >= PF_LIMIT_MAX) {
+			error = EINVAL;
+			goto fail;
+		}
+		pl->limit = pf_pool_limits[pl->index].limit;
+		break;
+	}
+
+	case DIOCSETLIMIT: {
+		struct pfioc_limit *pl = (struct pfioc_limit *)addr;
+		int old_limit;
+
+		if (pl->index < 0 || pl->index >= PF_LIMIT_MAX) {
+			error = EINVAL;
+			goto fail;
+		}
+#if 0
+		if (pool_sethardlimit(pf_pool_limits[pl->index].pp,
+		    pl->limit, NULL, 0) != 0) {
+			error = EBUSY;
+			goto fail;
+		}
+#endif
+		old_limit = pf_pool_limits[pl->index].limit;
+		pf_pool_limits[pl->index].limit = pl->limit;
+		pl->limit = old_limit;
+		break;
+	}
+
+	case DIOCSETDEBUG: {
+		u_int32_t *level = (u_int32_t *)addr;
+		pf_status.debug = *level;
+		break;
+	}
+
+	case DIOCCLRRULECTRS: {
+		struct pf_rule *rule;
+
+		s = splnet();
+		TAILQ_FOREACH(rule, pf_rules_active, entries)
+			rule->evaluations = rule->packets =
+			    rule->bytes = 0;
+		splx(s);
+		break;
+	}
+
+	default:
+		error = ENODEV;
+		break;
+	}
+fail:
+
+	return (error);
+}
diff -Nur /usr/src/sys.orig/net/pf_norm.c /usr/src/sys/net/pf_norm.c
--- /usr/src/sys.orig/net/pf_norm.c	Thu Jan  1 08:00:00 1970
+++ /usr/src/sys/net/pf_norm.c	Thu Jul 10 10:51:40 2025
@@ -0,0 +1,1173 @@
+/*	$OpenBSD: pf_norm.c,v 1.35 2002/06/28 00:08:23 deraadt Exp $ */
+
+/*
+ * Copyright 2001 Niels Provos <provos@citi.umich.edu>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef NPFLOG
+#include "pflog.h"
+#endif
+
+#include "opt_inet.h"
+#include "opt_inet6.h"
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/mbuf.h>
+#include <sys/filio.h>
+#include <sys/fcntl.h>
+#include <sys/socket.h>
+#include <sys/kernel.h>
+#include <sys/time.h>
+
+#include <net/if.h>
+#include <net/if_types.h>
+#include <net/bpf.h>
+#include <net/route.h>
+#include <net/if_pflog.h>
+
+#include <netinet/in.h>
+#include <netinet/in_var.h>
+#include <netinet/in_systm.h>
+#include <netinet/ip.h>
+#include <netinet/ip_var.h>
+#include <netinet/tcp.h>
+#include <netinet/tcp_seq.h>
+#include <netinet/udp.h>
+#include <netinet/ip_icmp.h>
+
+#include <net/pfvar.h>
+
+struct timeval	 time;
+
+#ifdef __FreeBSD__
+#undef KASSERT
+#define KASSERT(x)
+#endif /* __FreeBSD__ */
+
+struct pf_frent {
+	LIST_ENTRY(pf_frent) fr_next;
+	struct ip *fr_ip;
+	struct mbuf *fr_m;
+};
+
+struct pf_frcache {
+	LIST_ENTRY(pf_frcache) fr_next;
+	uint16_t	fr_off;
+	uint16_t	fr_end;
+};
+
+#define PFFRAG_SEENLAST	0x0001		/* Seen the last fragment for this */
+#define PFFRAG_NOBUFFER	0x0002		/* Non-buffering fragment cache */
+#define PFFRAG_DROP	0x0004		/* Drop all fragments */
+#define BUFFER_FRAGMENTS(fr)	(!((fr)->fr_flags & PFFRAG_NOBUFFER))
+
+struct pf_fragment {
+	RB_ENTRY(pf_fragment) fr_entry;
+	TAILQ_ENTRY(pf_fragment) frag_next;
+	struct in_addr	fr_src;
+	struct in_addr	fr_dst;
+	u_int8_t	fr_p;		/* protocol of this fragment */
+	u_int8_t	fr_flags;	/* status flags */
+	u_int16_t	fr_id;		/* fragment id for reassemble */
+	u_int16_t	fr_max;		/* fragment data max */
+	u_int32_t	fr_timeout;
+#define fr_queue	fr_u.fru_queue
+#define fr_cache	fr_u.fru_cache
+	union {
+		LIST_HEAD(pf_fragq, pf_frent) fru_queue;	/* buffering */
+		LIST_HEAD(pf_cacheq, pf_frcache) fru_cache;	/* non-buf */
+	} fr_u;
+};
+
+TAILQ_HEAD(pf_fragqueue, pf_fragment)	pf_fragqueue;
+TAILQ_HEAD(pf_cachequeue, pf_fragment)	pf_cachequeue;
+
+static int		 pf_frag_compare(struct pf_fragment *,
+			    struct pf_fragment *);
+RB_HEAD(pf_frag_tree, pf_fragment)	pf_frag_tree, pf_cache_tree;
+RB_PROTOTYPE(pf_frag_tree, pf_fragment, fr_entry, pf_frag_compare);
+RB_GENERATE(pf_frag_tree, pf_fragment, fr_entry, pf_frag_compare);
+
+/* Private prototypes */
+void			 pf_ip2key(struct pf_fragment *, struct ip *);
+void			 pf_remove_fragment(struct pf_fragment *);
+void			 pf_flush_fragments(void);
+void			 pf_free_fragment(struct pf_fragment *);
+struct pf_fragment	*pf_find_fragment(struct ip *, struct pf_frag_tree *);
+struct mbuf		*pf_reassemble(struct mbuf **, struct pf_fragment *,
+			    struct pf_frent *, int);
+struct mbuf		*pf_fragcache(struct mbuf **, struct ip*,
+			    struct pf_fragment *, int, int, int *);
+u_int16_t		 pf_cksum_fixup(u_int16_t, u_int16_t, u_int16_t);
+int			 pf_normalize_tcp(int, struct ifnet *, struct mbuf *,
+			    int, int, void *, struct pf_pdesc *);
+int			 pf_normalize_tcpopt(struct pf_rule *, struct mbuf *,
+			    struct tcphdr *, int);
+
+#define	DPFPRINTF(x)	if (pf_status.debug >= PF_DEBUG_MISC) \
+			    { printf("%s: ", __func__); printf x ;}
+
+#if NPFLOG > 0
+#define PFLOG_PACKET(i,x,a,b,c,d,e) \
+	do { \
+		if (b == AF_INET) { \
+			HTONS(((struct ip *)x)->ip_len); \
+			HTONS(((struct ip *)x)->ip_off); \
+			pflog_packet(i,a,b,c,d,e); \
+			NTOHS(((struct ip *)x)->ip_len); \
+			NTOHS(((struct ip *)x)->ip_off); \
+		} else \
+			pflog_packet(i,a,b,c,d,e); \
+	} while (0)
+#else
+#define PFLOG_PACKET(i,x,a,b,c,d,e)     ((void)0)
+#endif
+
+/* Globals */
+pool_t			 pf_frent_pl, pf_frag_pl, pf_cache_pl, pf_cent_pl;
+int			 pf_nfrents, pf_ncache;
+extern int		 pftm_frag;	/* Fragment expire timeout */
+
+void
+pf_normalize_init(void)
+{
+	pool_init(&pf_frent_pl, sizeof(struct pf_frent), 0, 0, 0, "pffrent",
+	    NULL);
+	pool_init(&pf_frag_pl, sizeof(struct pf_fragment), 0, 0, 0, "pffrag",
+	    NULL);
+	pool_init(&pf_cache_pl, sizeof(struct pf_fragment), 0, 0, 0,
+	    "pffrcache", NULL);
+	pool_init(&pf_cent_pl, sizeof(struct pf_frcache), 0, 0, 0, "pffrcent",
+	    NULL);
+
+#if 0
+	pool_sethiwat(&pf_frag_pl, PFFRAG_FRAG_HIWAT);
+	pool_sethardlimit(&pf_frent_pl, PFFRAG_FRENT_HIWAT, NULL, 0);
+	pool_sethardlimit(&pf_cache_pl, PFFRAG_FRCACHE_HIWAT, NULL, 0);
+	pool_sethardlimit(&pf_cent_pl, PFFRAG_FRCENT_HIWAT, NULL, 0);
+#endif
+
+	TAILQ_INIT(&pf_fragqueue);
+	TAILQ_INIT(&pf_cachequeue);
+}
+
+static int
+pf_frag_compare(struct pf_fragment *a, struct pf_fragment *b)
+{
+	int diff;
+
+	if ((diff = a->fr_id - b->fr_id))
+		return (diff);
+	else if ((diff = a->fr_p - b->fr_p))
+		return (diff);
+	else if (a->fr_src.s_addr < b->fr_src.s_addr)
+		return (-1);
+	else if (a->fr_src.s_addr > b->fr_src.s_addr)
+		return (1);
+	else if (a->fr_dst.s_addr < b->fr_dst.s_addr)
+		return (-1);
+	else if (a->fr_dst.s_addr > b->fr_dst.s_addr)
+		return (1);
+	return (0);
+}
+
+void
+pf_purge_expired_fragments(void)
+{
+	struct pf_fragment *frag;
+	u_int32_t expire = time_second - pftm_frag;
+
+	while ((frag = TAILQ_LAST(&pf_fragqueue, pf_fragqueue)) != NULL) {
+		KASSERT(BUFFER_FRAGMENTS(frag));
+		if (frag->fr_timeout > expire)
+			break;
+
+		DPFPRINTF(("expiring %d(%p)\n", frag->fr_id, frag));
+		pf_free_fragment(frag);
+	}
+
+	while ((frag = TAILQ_LAST(&pf_cachequeue, pf_cachequeue)) != NULL) {
+		KASSERT(!BUFFER_FRAGMENTS(frag));
+		if (frag->fr_timeout > expire)
+			break;
+
+		DPFPRINTF(("expiring %d(%p)\n", frag->fr_id, frag));
+		pf_free_fragment(frag);
+		KASSERT(TAILQ_EMPTY(&pf_cachequeue) ||
+		    TAILQ_LAST(&pf_cachequeue, pf_cachequeue) != frag);
+	}
+}
+
+/*
+ *  Try to flush old fragments to make space for new ones
+ */
+
+void
+pf_flush_fragments(void)
+{
+	struct pf_fragment *frag;
+	int goal;
+
+	goal = pf_nfrents * 9 / 10;
+	DPFPRINTF(("trying to free > %d frents\n",
+		   pf_nfrents - goal));
+	while (goal < pf_nfrents) {
+		frag = TAILQ_LAST(&pf_fragqueue, pf_fragqueue);
+		if (frag == NULL)
+			break;
+		pf_free_fragment(frag);
+	}
+
+
+	goal = pf_ncache * 9 / 10;
+	DPFPRINTF(("trying to free > %d cache entries\n",
+		   pf_ncache - goal));
+	while (goal < pf_ncache) {
+		frag = TAILQ_LAST(&pf_cachequeue, pf_cachequeue);
+		if (frag == NULL)
+			break;
+		pf_free_fragment(frag);
+	}
+}
+
+/* Frees the fragments and all associated entries */
+
+void
+pf_free_fragment(struct pf_fragment *frag)
+{
+	struct pf_frent *frent;
+	struct pf_frcache *frcache;
+
+	/* Free all fragments */
+	if (BUFFER_FRAGMENTS(frag)) {
+		for (frent = LIST_FIRST(&frag->fr_queue); frent;
+		    frent = LIST_FIRST(&frag->fr_queue)) {
+			LIST_REMOVE(frent, fr_next);
+
+			m_freem(frent->fr_m);
+			pool_put(&pf_frent_pl, frent);
+			pf_nfrents--;
+		}
+	} else {
+		for (frcache = LIST_FIRST(&frag->fr_cache); frcache;
+		    frcache = LIST_FIRST(&frag->fr_cache)) {
+			LIST_REMOVE(frcache, fr_next);
+
+			KASSERT(LIST_EMPTY(&frag->fr_cache) ||
+			    LIST_FIRST(&frag->fr_cache)->fr_off >
+			    frcache->fr_end);
+
+			pool_put(&pf_cent_pl, frcache);
+			pf_ncache--;
+		}
+	}
+
+	pf_remove_fragment(frag);
+}
+
+void
+pf_ip2key(struct pf_fragment *key, struct ip *ip)
+{
+	key->fr_p = ip->ip_p;
+	key->fr_id = ip->ip_id;
+	key->fr_src.s_addr = ip->ip_src.s_addr;
+	key->fr_dst.s_addr = ip->ip_dst.s_addr;
+}
+
+struct pf_fragment *
+pf_find_fragment(struct ip *ip, struct pf_frag_tree *tree)
+{
+	struct pf_fragment key;
+	struct pf_fragment *frag;
+
+	pf_ip2key(&key, ip);
+
+	frag = RB_FIND(pf_frag_tree, tree, &key);
+	if (frag != NULL) {
+		/* XXX Are we sure we want to update the timeout? */
+		frag->fr_timeout = time_second;
+		if (BUFFER_FRAGMENTS(frag)) {
+			TAILQ_REMOVE(&pf_fragqueue, frag, frag_next);
+			TAILQ_INSERT_HEAD(&pf_fragqueue, frag, frag_next);
+		} else {
+			TAILQ_REMOVE(&pf_cachequeue, frag, frag_next);
+			TAILQ_INSERT_HEAD(&pf_cachequeue, frag, frag_next);
+		}
+	}
+
+	return (frag);
+}
+
+/* Removes a fragment from the fragment queue and frees the fragment */
+
+void
+pf_remove_fragment(struct pf_fragment *frag)
+{
+	if (BUFFER_FRAGMENTS(frag)) {
+		RB_REMOVE(pf_frag_tree, &pf_frag_tree, frag);
+		TAILQ_REMOVE(&pf_fragqueue, frag, frag_next);
+		pool_put(&pf_frag_pl, frag);
+	} else {
+		RB_REMOVE(pf_frag_tree, &pf_cache_tree, frag);
+		TAILQ_REMOVE(&pf_cachequeue, frag, frag_next);
+		pool_put(&pf_cache_pl, frag);
+	}
+}
+
+struct mbuf *
+pf_reassemble(struct mbuf **m0, struct pf_fragment *frag,
+    struct pf_frent *frent, int mff)
+{
+	struct mbuf *m = *m0, *m2;
+	struct pf_frent *frea, *next;
+	struct pf_frent *frep = NULL;
+	struct ip *ip = frent->fr_ip;
+	int hlen = ip->ip_hl << 2;
+	u_int16_t off = ip->ip_off;
+	u_int16_t max = ip->ip_len + off;
+
+	KASSERT(frag == NULL || BUFFER_FRAGMENTS(frag));
+
+	/* Strip off ip header */
+	m->m_data += hlen;
+	m->m_len -= hlen;
+
+	/* Create a new reassembly queue for this packet */
+	if (frag == NULL) {
+		frag = pool_get(&pf_frag_pl, PR_NOWAIT);
+		if (frag == NULL) {
+			pf_flush_fragments();
+			frag = pool_get(&pf_frag_pl, PR_NOWAIT);
+			if (frag == NULL)
+				goto drop_fragment;
+		}
+
+		frag->fr_flags = 0;
+		frag->fr_max = 0;
+		frag->fr_src = frent->fr_ip->ip_src;
+		frag->fr_dst = frent->fr_ip->ip_dst;
+		frag->fr_p = frent->fr_ip->ip_p;
+		frag->fr_id = frent->fr_ip->ip_id;
+		frag->fr_timeout = time_second;
+		LIST_INIT(&frag->fr_queue);
+
+		RB_INSERT(pf_frag_tree, &pf_frag_tree, frag);
+		TAILQ_INSERT_HEAD(&pf_fragqueue, frag, frag_next);
+
+		/* We do not have a previous fragment */
+		frep = NULL;
+		goto insert;
+	}
+
+	/*
+	 * Find a fragment after the current one:
+	 *  - off contains the real shifted offset.
+	 */
+	LIST_FOREACH(frea, &frag->fr_queue, fr_next) {
+		if (frea->fr_ip->ip_off > off)
+			break;
+		frep = frea;
+	}
+
+	KASSERT(frep != NULL || frea != NULL);
+
+	if (frep != NULL) {
+		u_int16_t precut;
+
+		precut = frep->fr_ip->ip_off + frep->fr_ip->ip_len - off;
+		if (precut >= ip->ip_len)
+			goto drop_fragment;
+		if (precut) {
+			m_adj(frent->fr_m, precut);
+
+			DPFPRINTF(("overlap -%d\n", precut));
+			/* Enforce 8 byte boundaries */
+			off = ip->ip_off += precut;
+			ip->ip_len -= precut;
+		}
+	}
+
+	for (; frea != NULL && ip->ip_len + off > frea->fr_ip->ip_off;
+	    frea = next) {
+		u_int16_t aftercut;
+
+		aftercut = (ip->ip_len + off) - frea->fr_ip->ip_off;
+		DPFPRINTF(("adjust overlap %d\n", aftercut));
+		if (aftercut < frea->fr_ip->ip_len) {
+			frea->fr_ip->ip_len -= aftercut;
+			frea->fr_ip->ip_off += aftercut;
+			m_adj(frea->fr_m, aftercut);
+			break;
+		}
+
+		/* This fragment is completely overlapped, loose it */
+		next = LIST_NEXT(frea, fr_next);
+		m_freem(frea->fr_m);
+		LIST_REMOVE(frea, fr_next);
+		pool_put(&pf_frent_pl, frea);
+		pf_nfrents--;
+	}
+
+ insert:
+	/* Update maximum data size */
+	if (frag->fr_max < max)
+		frag->fr_max = max;
+	/* This is the last segment */
+	if (!mff)
+		frag->fr_flags |= PFFRAG_SEENLAST;
+
+	if (frep == NULL)
+		LIST_INSERT_HEAD(&frag->fr_queue, frent, fr_next);
+	else
+		LIST_INSERT_AFTER(frep, frent, fr_next);
+
+	/* Check if we are completely reassembled */
+	if (!(frag->fr_flags & PFFRAG_SEENLAST))
+		return (NULL);
+
+	/* Check if we have all the data */
+	off = 0;
+	for (frep = LIST_FIRST(&frag->fr_queue); frep; frep = next) {
+		next = LIST_NEXT(frep, fr_next);
+
+		off += frep->fr_ip->ip_len;
+		if (off < frag->fr_max &&
+		    (next == NULL || next->fr_ip->ip_off != off)) {
+			DPFPRINTF(("missing fragment at %d, next %d, max %d\n",
+			    off, next == NULL ? -1 : next->fr_ip->ip_off,
+			    frag->fr_max));
+			return (NULL);
+		}
+	}
+	DPFPRINTF(("%d < %d?\n", off, frag->fr_max));
+	if (off < frag->fr_max)
+		return (NULL);
+
+	/* We have all the data */
+	frent = LIST_FIRST(&frag->fr_queue);
+	KASSERT(frent != NULL);
+	if ((frent->fr_ip->ip_hl << 2) + off > IP_MAXPACKET) {
+		DPFPRINTF(("drop: too big: %d\n", off));
+		pf_free_fragment(frag);
+		return (NULL);
+	}
+	next = LIST_NEXT(frent, fr_next);
+
+	/* Magic from ip_input */
+	ip = frent->fr_ip;
+	m = frent->fr_m;
+	m2 = m->m_next;
+	m->m_next = NULL;
+	m_cat(m, m2);
+	pool_put(&pf_frent_pl, frent);
+	pf_nfrents--;
+	for (frent = next; frent != NULL; frent = next) {
+		next = LIST_NEXT(frent, fr_next);
+
+		m2 = frent->fr_m;
+		pool_put(&pf_frent_pl, frent);
+		pf_nfrents--;
+		m_cat(m, m2);
+	}
+
+	ip->ip_src = frag->fr_src;
+	ip->ip_dst = frag->fr_dst;
+
+	/* Remove from fragment queue */
+	pf_remove_fragment(frag);
+
+	hlen = ip->ip_hl << 2;
+	ip->ip_len = off + hlen;
+	m->m_len += hlen;
+	m->m_data -= hlen;
+
+	/* some debugging cruft by sklower, below, will go away soon */
+	/* XXX this should be done elsewhere */
+	if (m->m_flags & M_PKTHDR) {
+		int plen = 0;
+		for (m2 = m; m2; m2 = m2->m_next)
+			plen += m2->m_len;
+		m->m_pkthdr.len = plen;
+	}
+
+	DPFPRINTF(("complete: %p(%d)\n", m, ip->ip_len));
+	return (m);
+
+ drop_fragment:
+	/* Oops - fail safe - drop packet */
+	pool_put(&pf_frent_pl, frent);
+	pf_nfrents--;
+	m_freem(m);
+	return (NULL);
+}
+
+struct mbuf *
+pf_fragcache(struct mbuf **m0, struct ip *h, struct pf_fragment *frag, int mff,
+    int drop, int *nomem)
+{
+	struct mbuf *m = *m0;
+	struct pf_frcache *frp, *fra, *cur = NULL;
+	int ip_len = h->ip_len - (h->ip_hl << 2);
+	u_int16_t off = h->ip_off << 3;
+	u_int16_t max = ip_len + off;
+	int hosed = 0;
+
+	KASSERT(frag == NULL || !BUFFER_FRAGMENTS(frag));
+
+	/* Create a new range queue for this packet */
+	if (frag == NULL) {
+		frag = pool_get(&pf_cache_pl, PR_NOWAIT);
+		if (frag == NULL) {
+			pf_flush_fragments();
+			frag = pool_get(&pf_cache_pl, PR_NOWAIT);
+			if (frag == NULL)
+				goto no_mem;
+		}
+
+		/* Get an entry for the queue */
+		cur = pool_get(&pf_cent_pl, PR_NOWAIT);
+		if (cur == NULL) {
+			pool_put(&pf_cache_pl, frag);
+			goto no_mem;
+		}
+		pf_ncache++;
+
+		frag->fr_flags = PFFRAG_NOBUFFER;
+		frag->fr_max = 0;
+		frag->fr_src = h->ip_src;
+		frag->fr_dst = h->ip_dst;
+		frag->fr_p = h->ip_p;
+		frag->fr_id = h->ip_id;
+		frag->fr_timeout = time_second;
+
+		cur->fr_off = off;
+		cur->fr_end = max;
+		LIST_INIT(&frag->fr_cache);
+		LIST_INSERT_HEAD(&frag->fr_cache, cur, fr_next);
+
+		RB_INSERT(pf_frag_tree, &pf_cache_tree, frag);
+		TAILQ_INSERT_HEAD(&pf_cachequeue, frag, frag_next);
+
+		DPFPRINTF(("fragcache[%d]: new %d-%d\n", h->ip_id, off, max));
+
+		goto pass;
+	}
+
+	/*
+	 * Find a fragment after the current one:
+	 *  - off contains the real shifted offset.
+	 */
+	frp = NULL;
+	LIST_FOREACH(fra, &frag->fr_cache, fr_next) {
+		if (fra->fr_off > off)
+			break;
+		frp = fra;
+	}
+
+	KASSERT(frp != NULL || fra != NULL);
+
+	if (frp != NULL) {
+		int precut;
+
+		precut = frp->fr_end - off;
+		if (precut >= ip_len) {
+			/* Fragment is entirely a duplicate */
+			DPFPRINTF(("fragcache[%d]: dead (%d-%d) %d-%d\n",
+			    h->ip_id, frp->fr_off, frp->fr_end, off, max));
+			goto drop_fragment;
+		}
+		if (precut == 0) {
+			/* They are adjacent.  Fixup cache entry */
+			DPFPRINTF(("fragcache[%d]: adjacent (%d-%d) %d-%d\n",
+			    h->ip_id, frp->fr_off, frp->fr_end, off, max));
+			frp->fr_end = max;
+		} else if (precut > 0) {
+			/* The first part of this payload overlaps with a
+			 * fragment that has already been passed.
+			 * Need to trim off the first part of the payload.
+			 * But to do so easily, we need to create another
+			 * mbuf to throw the original header into.
+			 */
+
+			DPFPRINTF(("fragcache[%d]: chop %d (%d-%d) %d-%d\n",
+			    h->ip_id, precut, frp->fr_off, frp->fr_end, off,
+			    max));
+
+			off += precut;
+			max -= precut;
+			/* Update the previous frag to encompas this one */
+			frp->fr_end = max;
+
+			if (!drop) {
+				/* XXX Optimization opportunity
+				 * This is a very heavy way to trim the payload.
+				 * we could do it much faster by diddling mbuf
+				 * internals but that would be even less legible
+				 * than this mbuf magic.  For my next trick,
+				 * I'll pull a rabbit out of my laptop.
+				 */
+				*m0 = m_dup(m, M_NOWAIT);
+				m_adj(*m0, (h->ip_hl << 2) - (*m0)->m_pkthdr.len);
+				if (*m0 == NULL)
+					goto no_mem;
+				KASSERT((*m0)->m_next == NULL);
+				m_adj(m, precut + (h->ip_hl << 2));
+				m_cat(*m0, m);
+				m = *m0;
+				if (m->m_flags & M_PKTHDR) {
+					int plen = 0;
+					struct mbuf *t;
+					for (t = m; t; t = t->m_next)
+						plen += t->m_len;
+					m->m_pkthdr.len = plen;
+				}
+
+
+				h = mtod(m, struct ip *);
+
+				KASSERT(m->m_len == h->ip_len - precut);
+
+				h->ip_off += precut >> 3;
+				h->ip_len -= precut;
+			} else {
+				hosed++;
+			}
+		} else {
+			/* There is a gap between fragments */
+
+			DPFPRINTF(("fragcache[%d]: gap %d (%d-%d) %d-%d\n",
+			    h->ip_id, -precut, frp->fr_off, frp->fr_end, off,
+			    max));
+
+			cur = pool_get(&pf_cent_pl, PR_NOWAIT);
+			if (cur == NULL)
+				goto no_mem;
+			pf_ncache++;
+
+			cur->fr_off = off;
+			cur->fr_end = max;
+			LIST_INSERT_AFTER(frp, cur, fr_next);
+		}
+	}
+
+	if (fra != NULL) {
+		int aftercut;
+		int merge = 0;
+
+		aftercut = max - fra->fr_off;
+		if (aftercut == 0) {
+			/* Adjacent fragments */
+			DPFPRINTF(("fragcache[%d]: adjacent %d-%d (%d-%d)\n",
+			    h->ip_id, off, max, fra->fr_off, fra->fr_end));
+			fra->fr_off = off;
+			merge = 1;
+		} else if (aftercut > 0) {
+			/* Need to chop off the tail of this fragment */
+			DPFPRINTF(("fragcache[%d]: chop %d %d-%d (%d-%d)\n",
+			    h->ip_id, aftercut, off, max, fra->fr_off,
+			    fra->fr_end));
+			fra->fr_off = off;
+			max -= aftercut;
+
+			merge = 1;
+
+			if (!drop) {
+				m_adj(m, -aftercut);
+				if (m->m_flags & M_PKTHDR) {
+					int plen = 0;
+					struct mbuf *t;
+					for (t = m; t; t = t->m_next)
+						plen += t->m_len;
+					m->m_pkthdr.len = plen;
+				}
+				h = mtod(m, struct ip *);
+				KASSERT(m->m_len == h->ip_len - aftercut);
+				h->ip_len -= aftercut;
+			} else {
+				hosed++;
+			}
+		} else {
+			/* There is a gap between fragments */
+			DPFPRINTF(("fragcache[%d]: gap %d %d-%d (%d-%d)\n",
+			    h->ip_id, -aftercut, off, max, fra->fr_off,
+			    fra->fr_end));
+
+			cur = pool_get(&pf_cent_pl, PR_NOWAIT);
+			if (cur == NULL)
+				goto no_mem;
+			pf_ncache++;
+
+			cur->fr_off = off;
+			cur->fr_end = max;
+			LIST_INSERT_BEFORE(fra, cur, fr_next);
+		}
+
+
+		/* Need to glue together two seperate fragment descriptors */
+		if (merge) {
+			if (cur && fra->fr_off <= cur->fr_end) {
+				/* Need to merge in a previous 'cur' */
+				DPFPRINTF(("fragcache[%d]: adjacent(merge %d-%d) %d-%d (%d-%d)\n",
+				    h->ip_id, cur->fr_off, cur->fr_end, off,
+				    max, fra->fr_off, fra->fr_end));
+				fra->fr_off = cur->fr_off;
+				LIST_REMOVE(cur, fr_next);
+				pool_put(&pf_cent_pl, cur);
+				pf_ncache--;
+				cur = NULL;
+
+			} else if (frp && fra->fr_off <= frp->fr_end) {
+				/* Need to merge in a modified 'frp' */
+				KASSERT(cur == NULL);
+				DPFPRINTF(("fragcache[%d]: adjacent(merge %d-%d) %d-%d (%d-%d)\n",
+				    h->ip_id, frp->fr_off, frp->fr_end, off,
+				    max, fra->fr_off, fra->fr_end));
+				fra->fr_off = frp->fr_off;
+				LIST_REMOVE(frp, fr_next);
+				pool_put(&pf_cent_pl, frp);
+				pf_ncache--;
+				frp = NULL;
+
+			}
+		}
+	}
+
+	if (hosed) {
+		/*
+		 * We must keep tracking the overall fragment even when
+		 * we're going to drop it anyway so that we know when to
+		 * free the overall descriptor.  Thus we drop the frag late.
+		 */
+		goto drop_fragment;
+	}
+
+
+ pass:
+	/* Update maximum data size */
+	if (frag->fr_max < max)
+		frag->fr_max = max;
+
+	/* This is the last segment */
+	if (!mff)
+		frag->fr_flags |= PFFRAG_SEENLAST;
+
+	/* Check if we are completely reassembled */
+	if ((frag->fr_flags & PFFRAG_SEENLAST) &&
+	    LIST_FIRST(&frag->fr_cache)->fr_off == 0 &&
+	    LIST_FIRST(&frag->fr_cache)->fr_end == frag->fr_max) {
+		/* Remove from fragment queue */
+		DPFPRINTF(("fragcache[%d]: done 0-%d\n", h->ip_id,
+		    frag->fr_max));
+		pf_free_fragment(frag);
+	}
+
+	return (m);
+
+ no_mem:
+	*nomem = 1;
+
+	/* Still need to pay attention to !IP_MF */
+	if (!mff && frag)
+		frag->fr_flags |= PFFRAG_SEENLAST;
+
+	m_freem(m);
+	return (NULL);
+
+ drop_fragment:
+
+	/* Still need to pay attention to !IP_MF */
+	if (!mff && frag)
+		frag->fr_flags |= PFFRAG_SEENLAST;
+
+	if (drop) {
+		/* This fragment has been deemed bad.  Don't reass */
+		if ((frag->fr_flags & PFFRAG_DROP) == 0)
+			DPFPRINTF(("fragcache[%d]: dropping overall fragment\n",
+			    h->ip_id));
+		frag->fr_flags |= PFFRAG_DROP;
+	}
+
+	m_freem(m);
+	return (NULL);
+}
+
+int
+pf_normalize_ip(struct mbuf **m0, int dir, struct ifnet *ifp, u_short *reason)
+{
+	struct mbuf *m = *m0;
+	struct pf_rule *r;
+	struct pf_frent *frent;
+	struct pf_fragment *frag = NULL;
+	struct ip *h = mtod(m, struct ip *);
+	int mff = (h->ip_off & IP_MF), hlen = h->ip_hl << 2;
+	u_int16_t fragoff = (h->ip_off & IP_OFFMASK) << 3;
+	u_int16_t max;
+	int ip_len;
+	int ip_off;
+
+	r = TAILQ_FIRST(pf_rules_active);
+	while (r != NULL) {
+		if (r->action != PF_SCRUB)
+			r = r->skip[PF_SKIP_ACTION];
+		else if (r->ifp != NULL && r->ifp != ifp)
+			r = r->skip[PF_SKIP_IFP];
+		else if (r->direction != dir)
+			r = r->skip[PF_SKIP_DIR];
+		else if (r->af && r->af != AF_INET)
+			r = r->skip[PF_SKIP_AF];
+		else if (r->proto && r->proto != h->ip_p)
+			r = r->skip[PF_SKIP_PROTO];
+		else if (!PF_AZERO(&r->src.mask, AF_INET) &&
+		    !PF_MATCHA(r->src.not, &r->src.addr.addr, &r->src.mask,
+		    (struct pf_addr *)&h->ip_src.s_addr, AF_INET))
+			r = r->skip[PF_SKIP_SRC_ADDR];
+		else if (!PF_AZERO(&r->dst.mask, AF_INET) &&
+		    !PF_MATCHA(r->dst.not, &r->dst.addr.addr, &r->dst.mask,
+		    (struct pf_addr *)&h->ip_dst.s_addr, AF_INET))
+			r = r->skip[PF_SKIP_DST_ADDR];
+		else
+			break;
+	}
+
+	if (r == NULL)
+		return (PF_PASS);
+
+	/* Check for illegal packets */
+	if (hlen < sizeof(struct ip))
+		goto drop;
+
+	if (hlen > h->ip_len)
+		goto drop;
+
+	/* We will need other tests here */
+	if (!fragoff && !mff)
+		goto no_fragment;
+
+	/* This can not happen */
+	if (h->ip_off & IP_DF) {
+		DPFPRINTF(("IP_DF\n"));
+		goto bad;
+	}
+
+	ip_len = h->ip_len - hlen;
+	ip_off = h->ip_off << 3;
+
+	/* All fragments are 8 byte aligned */
+	if (mff && (ip_len & 0x7)) {
+		DPFPRINTF(("mff and %d\n", ip_len));
+		goto bad;
+	}
+
+	max = fragoff + ip_len;
+	/* Respect maximum length */
+	if (max > IP_MAXPACKET) {
+		DPFPRINTF(("max packet %d\n", max));
+		goto bad;
+	}
+
+	if ((r->rule_flag & (PFRULE_FRAGCROP|PFRULE_FRAGDROP)) == 0) {
+		/* Fully buffer all of the fragments */
+
+		h->ip_len = ip_len;	/* logic need muddled off/len */
+		h->ip_off = ip_off;
+		frag = pf_find_fragment(h, &pf_frag_tree);
+
+		/* Check if we saw the last fragment already */
+		if (frag != NULL && (frag->fr_flags & PFFRAG_SEENLAST) &&
+		    max > frag->fr_max)
+			goto bad;
+
+		/* Get an entry for the fragment queue */
+		frent = pool_get(&pf_frent_pl, PR_NOWAIT);
+		if (frent == NULL) {
+			REASON_SET(reason, PFRES_MEMORY);
+			return (PF_DROP);
+		}
+		pf_nfrents++;
+		frent->fr_ip = h;
+		frent->fr_m = m;
+
+		/* Might return a completely reassembled mbuf, or NULL */
+		DPFPRINTF(("reass frag %d @ %d-%d\n", h->ip_id, fragoff, max));
+		*m0 = m = pf_reassemble(m0, frag, frent, mff);
+
+		if (m == NULL)
+			return (PF_DROP);
+
+		if (frag && (frag->fr_flags & PFFRAG_DROP))
+			goto drop;
+
+		h = mtod(m, struct ip *);
+	} else {
+		/* non-buffering fragment cache (drops or masks overlaps) */
+		int nomem = 0;
+
+		if (dir == PF_OUT) {
+			if (m_tag_find(m, PACKET_TAG_PF_FRAGCACHE, NULL) !=
+			    NULL) {
+				/* Already passed the fragment cache in the
+				 * input direction.  If we continued, it would
+				 * appear to be a dup and would be dropped.
+				 */
+				goto fragment_pass;
+			}
+		}
+
+		frag = pf_find_fragment(h, &pf_cache_tree);
+
+		/* Check if we saw the last fragment already */
+		if (frag != NULL && (frag->fr_flags & PFFRAG_SEENLAST) &&
+		    max > frag->fr_max) {
+			if (r->rule_flag & PFRULE_FRAGDROP)
+				frag->fr_flags |= PFFRAG_DROP;
+			goto bad;
+		}
+
+		*m0 = m = pf_fragcache(m0, h, frag, mff,
+		    (r->rule_flag & PFRULE_FRAGDROP) ? 1 : 0, &nomem);
+		if (m == NULL) {
+			if (nomem)
+				goto no_mem;
+			goto drop;
+		}
+
+		if (dir == PF_IN) {
+			struct m_tag *mtag;
+			mtag = m_tag_get(PACKET_TAG_PF_FRAGCACHE, 0, M_NOWAIT);
+			if (mtag == NULL)
+				goto no_mem;
+			m_tag_prepend(m, mtag);
+		}
+		if (frag && (frag->fr_flags & PFFRAG_DROP))
+			goto drop;
+		goto fragment_pass;
+	}
+
+ no_fragment:
+	if (dir != PF_OUT)
+		return (PF_PASS);
+
+	/* At this point, only IP_DF is allowed in ip_off */
+	if (r->rule_flag & PFRULE_NODF)
+		h->ip_off = 0;
+	else
+		h->ip_off &= IP_DF;
+
+	/* Enforce a minimum ttl, may cause endless packet loops */
+	if (r->min_ttl && h->ip_ttl < r->min_ttl)
+		h->ip_ttl = r->min_ttl;
+
+	return (PF_PASS);
+
+ fragment_pass:
+	if (dir != PF_OUT)
+		return (PF_PASS);
+
+	/* Enforce a minimum ttl, may cause endless packet loops */
+	if (r->min_ttl && h->ip_ttl < r->min_ttl)
+		h->ip_ttl = r->min_ttl;
+
+	return (PF_PASS);
+
+ no_mem:
+	REASON_SET(reason, PFRES_MEMORY);
+	if (r != NULL && r->log)
+		PFLOG_PACKET(ifp, h, m, AF_INET, dir, *reason, r);
+	return (PF_DROP);
+
+ drop:
+	REASON_SET(reason, PFRES_NORM);
+	if (r != NULL && r->log)
+		PFLOG_PACKET(ifp, h, m, AF_INET, dir, *reason, r);
+	return (PF_DROP);
+
+ bad:
+	DPFPRINTF(("dropping bad fragment\n"));
+
+	/* Free assoicated fragments */
+	if (frag != NULL)
+		pf_free_fragment(frag);
+
+	REASON_SET(reason, PFRES_FRAG);
+	if (r != NULL && r->log)
+		PFLOG_PACKET(ifp, h, m, AF_INET, dir, *reason, r);
+
+	return (PF_DROP);
+}
+
+int
+pf_normalize_tcp(int dir, struct ifnet *ifp, struct mbuf *m, int ipoff,
+    int off, void *h, struct pf_pdesc *pd)
+{
+	struct pf_rule *r, *rm = NULL;
+	struct tcphdr *th = pd->hdr.tcp;
+	int rewrite = 0;
+	u_short reason;
+	u_int8_t flags, af = pd->af;
+
+	r = TAILQ_FIRST(pf_rules_active);
+	while (r != NULL) {
+		if (r->action != PF_SCRUB)
+			r = r->skip[PF_SKIP_ACTION];
+		else if (r->ifp != NULL && r->ifp != ifp)
+			r = r->skip[PF_SKIP_IFP];
+		else if (r->direction != dir)
+			r = r->skip[PF_SKIP_DIR];
+		else if (r->af && r->af != af)
+			r = r->skip[PF_SKIP_AF];
+		else if (r->proto && r->proto != pd->proto)
+			r = r->skip[PF_SKIP_PROTO];
+		else if (r->src.noroute && pf_routable(pd->src, af))
+			r = TAILQ_NEXT(r, entries);
+		else if (!r->src.noroute && !PF_AZERO(&r->src.mask, af) &&
+		    !PF_MATCHA(r->src.not, &r->src.addr.addr, &r->src.mask,
+			    pd->src, af))
+			r = r->skip[PF_SKIP_SRC_ADDR];
+		else if (r->src.port_op && !pf_match_port(r->src.port_op,
+			    r->src.port[0], r->src.port[1], th->th_sport))
+			r = r->skip[PF_SKIP_SRC_PORT];
+		else if (r->dst.noroute && pf_routable(pd->dst, af))
+			r = TAILQ_NEXT(r, entries);
+		else if (!r->dst.noroute && !PF_AZERO(&r->dst.mask, af) &&
+		    !PF_MATCHA(r->dst.not, &r->dst.addr.addr, &r->dst.mask,
+			    pd->dst, af))
+			r = r->skip[PF_SKIP_DST_ADDR];
+		else if (r->dst.port_op && !pf_match_port(r->dst.port_op,
+			    r->dst.port[0], r->dst.port[1], th->th_dport))
+			r = r->skip[PF_SKIP_DST_PORT];
+		else {
+			rm = r;
+			break;
+		}
+	}
+
+	if (rm == NULL)
+		return (PF_PASS);
+
+	flags = th->th_flags;
+	if (flags & TH_SYN) {
+		/* Illegal packet */
+		if (flags & TH_RST)
+			goto tcp_drop;
+
+		if (flags & TH_FIN)
+			flags &= ~TH_FIN;
+	} else {
+		/* Illegal packet */
+		if (!(flags & (TH_ACK|TH_RST)))
+			goto tcp_drop;
+	}
+
+	if (!(flags & TH_ACK)) {
+		/* These flags are only valid if ACK is set */
+		if ((flags & TH_FIN) || (flags & TH_PUSH) || (flags & TH_URG))
+			goto tcp_drop;
+	}
+
+	/* Check for illegal header length */
+	if (th->th_off < (sizeof(struct tcphdr) >> 2))
+		goto tcp_drop;
+
+	/* If flags changed, or reserved data set, then adjust */
+	if (flags != th->th_flags || th->th_x2 != 0) {
+		u_int16_t ov, nv;
+
+		ov = *(u_int16_t *)(&th->th_ack + 1);
+		th->th_flags = flags;
+		th->th_x2 = 0;
+		nv = *(u_int16_t *)(&th->th_ack + 1);
+
+		th->th_sum = pf_cksum_fixup(th->th_sum, ov, nv);
+		rewrite = 1;
+	}
+
+	/* Remove urgent pointer, if TH_URG is not set */
+	if (!(flags & TH_URG) && th->th_urp) {
+		th->th_sum = pf_cksum_fixup(th->th_sum, th->th_urp, 0);
+		th->th_urp = 0;
+		rewrite = 1;
+	}
+
+	/* Process options */
+	if (r->max_mss && pf_normalize_tcpopt(r, m, th, off))
+		rewrite = 1;
+
+	/* copy back packet headers if we sanitized */
+	if (rewrite)
+		m_copyback(m, off, sizeof(*th), (caddr_t)th);
+
+	return (PF_PASS);
+
+ tcp_drop:
+	REASON_SET(&reason, PFRES_NORM);
+	if (rm != NULL && rm->log)
+		PFLOG_PACKET(ifp, h, m, AF_INET, dir, reason, rm);
+	return (PF_DROP);
+}
+
+int
+pf_normalize_tcpopt(struct pf_rule *r, struct mbuf *m, struct tcphdr *th,
+    int off)
+{
+	u_int16_t *mss;
+	int thoff;
+	int opt, cnt, optlen = 0;
+	int rewrite = 0;
+	u_char *optp;
+
+	thoff = th->th_off << 2;
+	cnt = thoff - sizeof(struct tcphdr);
+	optp = mtod(m, caddr_t) + off + sizeof(struct tcphdr);
+
+	for (; cnt > 0; cnt -= optlen, optp += optlen) {
+		opt = optp[0];
+		if (opt == TCPOPT_EOL)
+			break;
+		if (opt == TCPOPT_NOP)
+			optlen = 1;
+		else {
+			if (cnt < 2)
+				break;
+			optlen = optp[1];
+			if (optlen < 2 || optlen > cnt)
+				break;
+		}
+		switch (opt) {
+		case TCPOPT_MAXSEG:
+			mss = (u_int16_t *)(optp + 2);
+			if ((ntohs(*mss)) > r->max_mss) {
+				th->th_sum = pf_cksum_fixup(th->th_sum,
+				    *mss, htons(r->max_mss));
+				*mss = htons(r->max_mss);
+				rewrite = 1;
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	return (rewrite);
+}
diff -Nur /usr/src/sys.orig/net/pfvar.h /usr/src/sys/net/pfvar.h
--- /usr/src/sys.orig/net/pfvar.h	Thu Jan  1 08:00:00 1970
+++ /usr/src/sys/net/pfvar.h	Sun Jul  6 21:33:46 2025
@@ -0,0 +1,744 @@
+/*	$OpenBSD: pfvar.h,v 1.89 2002/08/12 16:41:25 dhartmei Exp $ */
+
+/*
+ * Copyright (c) 2001 Daniel Hartmeier
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *    - Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer. 
+ *    - Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials provided
+ *      with the distribution. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef _NET_PFVAR_H_
+#define _NET_PFVAR_H_
+
+#include <sys/types.h>
+#include <sys/queue.h>
+#include <sys/tree.h>
+
+typedef struct pool pool_t;
+
+#ifdef _KERNEL
+#include <sys/malloc.h>
+MALLOC_DECLARE(M_PF);
+
+#define pool_t			int
+#define pool_get(pool, flags)	malloc(*(pool), M_PF, M_DONTWAIT)
+#define pool_put(pool, item)	free(item, M_PF)
+#define pool_init(pool, size, a, ao, f, m, p)   \
+	do { (*(pool)) = (size); } while (0)
+#endif /* _KERNEL */
+
+enum	{ PF_IN=0, PF_OUT=1 };
+enum	{ PF_PASS=0, PF_DROP=1, PF_SCRUB=2 };
+enum	{ PF_OP_IRG=1, PF_OP_EQ=2, PF_OP_NE=3, PF_OP_LT=4,
+	  PF_OP_LE=5, PF_OP_GT=6, PF_OP_GE=7, PF_OP_XRG=8 };
+enum	{ PF_DEBUG_NONE=0, PF_DEBUG_URGENT=1, PF_DEBUG_MISC=2 };
+enum	{ PF_CHANGE_ADD_HEAD=1, PF_CHANGE_ADD_TAIL=2,
+	  PF_CHANGE_ADD_BEFORE=3, PF_CHANGE_ADD_AFTER=4,
+	  PF_CHANGE_REMOVE=5 };
+enum	{ PFTM_TCP_FIRST_PACKET=0, PFTM_TCP_OPENING=1, PFTM_TCP_ESTABLISHED=2,
+	  PFTM_TCP_CLOSING=3, PFTM_TCP_FIN_WAIT=4, PFTM_TCP_CLOSED=5,
+	  PFTM_UDP_FIRST_PACKET=6, PFTM_UDP_SINGLE=7, PFTM_UDP_MULTIPLE=8,
+	  PFTM_ICMP_FIRST_PACKET=9, PFTM_ICMP_ERROR_REPLY=10,
+	  PFTM_OTHER_FIRST_PACKET=11, PFTM_OTHER_SINGLE=12,
+	  PFTM_OTHER_MULTIPLE=13, PFTM_FRAG=14, PFTM_INTERVAL=15, PFTM_MAX=16 };
+enum	{ PF_FASTROUTE=1, PF_ROUTETO=2, PF_DUPTO=3 };
+enum	{ PF_LIMIT_STATES=0, PF_LIMIT_FRAGS=1, PF_LIMIT_MAX=2 };
+
+extern struct		pf_rule	pf_default_rule;
+
+struct pf_addr {
+	union {
+		struct in_addr		v4;
+		struct in6_addr		v6;
+		u_int8_t		addr8[16];
+		u_int16_t		addr16[8];
+		u_int32_t		addr32[4];
+		char			ifname[IFNAMSIZ];
+	} pfa;		    /* 128-bit address */
+#define v4	pfa.v4
+#define v6	pfa.v6
+#define addr8	pfa.addr8
+#define addr16	pfa.addr16
+#define addr32	pfa.addr32
+};
+
+struct pf_addr_wrap {
+	struct pf_addr		 addr;
+	struct pf_addr_dyn	*addr_dyn;
+};
+
+struct pf_addr_dyn {
+	char			 ifname[IFNAMSIZ];
+	struct ifnet		*ifp;
+	struct pf_addr		*addr;
+	u_int8_t		 af;
+	void			*hook_cookie;
+	u_int8_t		 undefined;
+};
+
+/*
+ * Address manipulation macros
+ */
+
+#ifdef _KERNEL
+
+#ifdef INET
+#ifndef INET6
+#define PF_INET_ONLY
+#endif /* ! INET6 */
+#endif /* INET */
+
+#ifdef INET6
+#ifndef INET
+#define PF_INET6_ONLY
+#endif /* ! INET */
+#endif /* INET6 */
+
+#ifdef INET
+#ifdef INET6
+#define PF_INET_INET6
+#endif /* INET6 */
+#endif /* INET */
+
+#else
+
+#define PF_INET_INET6
+
+#endif /* _KERNEL */
+
+/* Both IPv4 and IPv6 */
+#ifdef PF_INET_INET6
+
+#define PF_AEQ(a, b, c) \
+	((c == AF_INET && (a)->addr32[0] == (b)->addr32[0]) || \
+	(c == AF_INET6 && (a)->addr32[0] == (b)->addr32[0] && \
+	(a)->addr32[1] == (b)->addr32[1] && \
+	(a)->addr32[2] == (b)->addr32[2] && \
+	(a)->addr32[3] == (b)->addr32[3])) \
+
+#define PF_ANEQ(a, b, c) \
+	((c == AF_INET && (a)->addr32[0] != (b)->addr32[0]) || \
+	(c == AF_INET6 && ((a)->addr32[0] != (b)->addr32[0] || \
+	(a)->addr32[1] != (b)->addr32[1] || \
+	(a)->addr32[2] != (b)->addr32[2] || \
+	(a)->addr32[3] != (b)->addr32[3]))) \
+
+#define PF_AZERO(a, c) \
+	((c == AF_INET && !(a)->addr32[0]) || \
+	(c == AF_INET6 && !(a)->addr32[0] && \
+	!(a)->addr32[1] && !(a)->addr32[2] && \
+	!(a)->addr32[3] )) \
+
+#define PF_MATCHA(n, a, m, b, f) \
+	pf_match_addr(n, a, m, b, f)
+
+#define PF_ACPY(a, b, f) \
+	pf_addrcpy(a, b, f)
+
+#else
+
+/* Just IPv6 */
+#ifdef PF_INET6_ONLY
+
+#define PF_AEQ(a, b, c) \
+	((a)->addr32[0] == (b)->addr32[0] && \
+	(a)->addr32[1] == (b)->addr32[1] && \
+	(a)->addr32[2] == (b)->addr32[2] && \
+	(a)->addr32[3] == (b)->addr32[3]) \
+
+#define PF_ANEQ(a, b, c) \
+	((a)->addr32[0] != (b)->addr32[0] || \
+	(a)->addr32[1] != (b)->addr32[1] || \
+	(a)->addr32[2] != (b)->addr32[2] || \
+	(a)->addr32[3] != (b)->addr32[3]) \
+
+#define PF_AZERO(a, c) \
+	(!(a)->addr32[0] && \
+	!(a)->addr32[1] && \
+	!(a)->addr32[2] && \
+	!(a)->addr32[3] ) \
+
+#define PF_MATCHA(n, a, m, b, f) \
+	pf_match_addr(n, a, m, b, f)
+
+#define PF_ACPY(a, b, f) \
+	pf_addrcpy(a, b, f)
+
+#else
+
+/* Just IPv4 */
+#ifdef PF_INET_ONLY
+
+#define PF_AEQ(a, b, c) \
+	((a)->addr32[0] == (b)->addr32[0])
+
+#define PF_ANEQ(a, b, c) \
+	((a)->addr32[0] != (b)->addr32[0])
+
+#define PF_AZERO(a, c) \
+	(!(a)->addr32[0])
+
+#define PF_MATCHA(n, a, m, b, f) \
+	pf_match_addr(n, a, m, b, f)
+
+#define PF_ACPY(a, b, f) \
+	(a)->v4.s_addr = (b)->v4.s_addr
+
+#endif /* PF_INET_ONLY */
+#endif /* PF_INET6_ONLY */
+#endif /* PF_INET_INET6 */
+
+struct pf_rule_uid {
+	uid_t		 uid[2];
+	u_int8_t	 op;
+};
+
+struct pf_rule_gid {
+	uid_t		 gid[2];
+	u_int8_t	 op;
+};
+
+struct pf_rule_addr {
+	struct pf_addr_wrap	 addr;
+	struct pf_addr		 mask;
+	u_int16_t		 port[2];
+	u_int8_t		 not;
+	u_int8_t		 port_op;
+	u_int8_t		 noroute;
+};
+
+struct pf_rule {
+	struct pf_rule_addr	 src;
+	struct pf_rule_addr	 dst;
+#define PF_SKIP_ACTION		0
+#define PF_SKIP_IFP		1
+#define PF_SKIP_DIR		2
+#define PF_SKIP_AF		3
+#define PF_SKIP_PROTO		4
+#define PF_SKIP_SRC_ADDR	5
+#define PF_SKIP_SRC_PORT	6
+#define PF_SKIP_DST_ADDR	7
+#define PF_SKIP_DST_PORT	8
+#define PF_SKIP_COUNT		9
+	struct pf_rule		*skip[PF_SKIP_COUNT];
+#define PF_RULE_LABEL_SIZE	 64
+	char			 label[PF_RULE_LABEL_SIZE];
+	u_int32_t		 timeout[PFTM_MAX];
+	struct pf_addr		 rt_addr;
+	char			 ifname[IFNAMSIZ];
+	char			 rt_ifname[IFNAMSIZ];
+	TAILQ_ENTRY(pf_rule)	 entries;
+
+	u_int64_t		 evaluations;
+	u_int64_t		 packets;
+	u_int64_t		 bytes;
+
+	struct ifnet		*ifp;
+	struct ifnet		*rt_ifp;
+
+	u_int32_t		 states;
+	u_int32_t		 max_states;
+
+	u_int16_t		 nr;
+	u_int16_t		 return_icmp;
+	u_int16_t		 max_mss;
+
+	struct pf_rule_uid	 uid;
+	struct pf_rule_gid	 gid;
+
+	u_int8_t		 action;
+	u_int8_t		 direction;
+	u_int8_t		 log;
+	u_int8_t		 quick;
+	u_int8_t		 ifnot;
+
+#define PF_STATE_NORMAL		0x1
+#define PF_STATE_MODULATE	0x2
+	u_int8_t		 keep_state;
+	u_int8_t		 af;
+	u_int8_t		 proto;
+	u_int8_t		 type;
+	u_int8_t		 code;
+
+	u_int8_t		 flags;
+	u_int8_t		 flagset;
+	u_int8_t		 rule_flag;
+	u_int8_t		 min_ttl;
+	u_int8_t		 allow_opts;
+	u_int8_t		 rt;
+	u_int8_t		 return_ttl;
+};
+
+#define	PFRULE_RETURNRST	0x01
+#define	PFRULE_NODF		0x02
+#define	PFRULE_FRAGMENT		0x04
+
+#define	PFRULE_FRAGCROP		0x10	/* non-buffering frag cache */
+#define	PFRULE_FRAGDROP		0x20	/* drop funny fragments */
+
+struct pf_state_host {
+	struct pf_addr	addr;
+	u_int16_t	port;
+	u_int16_t	pad;
+};
+
+struct pf_state_peer {
+	u_int32_t	seqlo;		/* Max sequence number sent	*/
+	u_int32_t	seqhi;		/* Max the other end ACKd + win	*/
+	u_int32_t	seqdiff;	/* Sequence number modulator	*/
+	u_int16_t	max_win;
+	u_int8_t	state;
+	u_int8_t	pad;
+};
+
+struct pf_state {
+	struct pf_state_host lan;
+	struct pf_state_host gwy;
+	struct pf_state_host ext;
+	struct pf_state_peer src;
+	struct pf_state_peer dst;
+	union {
+		struct pf_rule	*ptr;
+		u_int16_t	 nr;
+	} rule;
+	u_int32_t	 creation;
+	u_int32_t	 expire;
+	u_int32_t	 packets;
+	u_int32_t	 bytes;
+	u_int8_t	 af;
+	u_int8_t	 proto;
+	u_int8_t	 direction;
+	u_int8_t	 log;
+	u_int8_t	 allow_opts;
+};
+
+struct pf_tree_node {
+	RB_ENTRY(pf_tree_node) entry;
+	struct pf_state	*state;
+	struct pf_addr	 addr[2];
+	u_int16_t	 port[2];
+	u_int8_t	 af;
+	u_int8_t	 proto;
+};
+
+
+struct pf_nat {
+	struct pf_rule_addr	 src;
+	struct pf_rule_addr	 dst;
+	struct pf_addr_wrap	 raddr;
+	char			 ifname[IFNAMSIZ];
+	struct ifnet		*ifp;
+	TAILQ_ENTRY(pf_nat)	 entries;
+	u_int16_t		 proxy_port[2];
+	u_int8_t		 af;
+	u_int8_t		 proto;
+	u_int8_t		 ifnot;
+	u_int8_t		 no;
+};
+
+struct pf_binat {
+	char			 ifname[IFNAMSIZ];
+	struct ifnet		*ifp;
+	TAILQ_ENTRY(pf_binat)	 entries;
+	struct pf_addr_wrap	 saddr;
+	struct pf_addr_wrap	 daddr;
+	struct pf_addr_wrap	 raddr;
+	struct pf_addr		 dmask;
+	u_int8_t		 af;
+	u_int8_t		 proto;
+	u_int8_t		 dnot;
+	u_int8_t		 no;
+};
+
+struct pf_rdr {
+	char			 ifname[IFNAMSIZ];
+	struct ifnet		*ifp;
+	TAILQ_ENTRY(pf_rdr)	 entries;
+	struct pf_addr_wrap	 saddr;
+	struct pf_addr_wrap	 daddr;
+	struct pf_addr_wrap	 raddr;
+	struct pf_addr		 smask;
+	struct pf_addr		 dmask;
+	u_int16_t		 dport;
+	u_int16_t		 dport2;
+	u_int16_t		 rport;
+	u_int8_t		 af;
+	u_int8_t		 proto;
+	u_int8_t		 snot;
+	u_int8_t		 dnot;
+	u_int8_t		 ifnot;
+	u_int8_t		 opts;
+	u_int8_t		 no;
+};
+
+TAILQ_HEAD(pf_rulequeue, pf_rule);
+
+struct pf_pdesc {
+	u_int64_t	 tot_len;	/* Make Mickey money */
+	union {
+		struct tcphdr		*tcp;
+		struct udphdr		*udp;
+		struct icmp		*icmp;
+#ifdef INET6
+		struct icmp6_hdr	*icmp6;
+#endif /* INET6 */
+		void			*any;
+	} hdr;
+	struct pf_addr	*src;
+	struct pf_addr	*dst;
+	u_int16_t	*ip_sum;
+	u_int32_t	 p_len;		/* total length of payload */
+	u_int16_t	 flags;		/* Let SCRUB trigger behavior in
+					 * state code. Easier than tags */
+	u_int8_t	 af;
+	u_int8_t	 proto;
+};
+
+/* flags for RDR options */
+#define PF_DPORT_RANGE	0x01		/* Dest port uses range */
+#define PF_RPORT_RANGE	0x02		/* RDR'ed port uses range */
+
+/* Reasons code for passing/dropping a packet */
+#define PFRES_MATCH	0		/* Explicit match of a rule */
+#define PFRES_BADOFF	1		/* Bad offset for pull_hdr */
+#define PFRES_FRAG	2		/* Dropping following fragment */
+#define PFRES_SHORT	3		/* Dropping short packet */
+#define PFRES_NORM	4		/* Dropping by normalizer */
+#define PFRES_MEMORY	5		/* Dropped due to lacking mem */
+#define PFRES_MAX	6		/* total+1 */
+
+#define PFRES_NAMES { \
+	"match", \
+	"bad-offset", \
+	"fragment", \
+	"short", \
+	"normalize", \
+	"memory", \
+	NULL \
+}
+
+/* UDP state enumeration */
+#define PFUDPS_NO_TRAFFIC	0
+#define PFUDPS_SINGLE		1
+#define PFUDPS_MULTIPLE		2
+
+#define PFUDPS_NSTATES		3	/* number of state levels */
+
+#define PFUDPS_NAMES { \
+	"NO TRAFFIC", \
+	"SINGLE", \
+	"MULTIPLE", \
+	NULL \
+}
+
+/* Other protocol state enumeration */
+#define PFOTHERS_NO_TRAFFIC	0
+#define PFOTHERS_SINGLE		1
+#define PFOTHERS_MULTIPLE	2
+
+#define PFOTHERS_NSTATES	3	/* number of state levels */
+
+#define PFOTHERS_NAMES { \
+	"NO TRAFFIC", \
+	"SINGLE", \
+	"MULTIPLE", \
+	NULL \
+}
+
+#define FCNT_STATE_SEARCH	0
+#define FCNT_STATE_INSERT	1
+#define FCNT_STATE_REMOVALS	2
+#define FCNT_MAX		3
+
+
+#define ACTION_SET(a, x) \
+	do { \
+		if ((a) != NULL) \
+			*(a) = (x); \
+	} while (0)
+
+#define REASON_SET(a, x) \
+	do { \
+		if ((a) != NULL) \
+			*(a) = (x); \
+		if (x < PFRES_MAX) \
+			pf_status.counters[x]++; \
+	} while (0)
+
+struct pf_status {
+	u_int64_t	counters[PFRES_MAX];
+	u_int64_t	fcounters[FCNT_MAX];
+	u_int64_t	pcounters[2][2][3];
+	u_int64_t	bcounters[2][2];
+	u_int32_t	running;
+	u_int32_t	states;
+	u_int32_t	since;
+	u_int32_t	debug;
+	char		ifname[IFNAMSIZ];
+};
+
+#define PFFRAG_FRENT_HIWAT	5000	/* Number of fragment entries */
+#define PFFRAG_FRAG_HIWAT	1000	/* Number of fragmented packets */
+#define PFFRAG_FRCENT_HIWAT	50000	/* Number of fragment cache entries */
+#define PFFRAG_FRCACHE_HIWAT	10000	/* Number of fragment descriptors */
+
+/*
+ * ioctl parameter structures
+ */
+
+struct pfioc_rule {
+	u_int32_t	 ticket;
+	u_int32_t	 nr;
+	struct pf_rule	 rule;
+};
+
+struct pfioc_changerule {
+	u_int32_t	 action;
+	struct pf_rule	 oldrule;
+	struct pf_rule	 newrule;
+};
+
+struct pfioc_nat {
+	u_int32_t	 ticket;
+	u_int32_t	 nr;
+	struct pf_nat	 nat;
+};
+
+struct pfioc_changenat {
+	u_int32_t	 action;
+	struct pf_nat	 oldnat;
+	struct pf_nat	 newnat;
+};
+
+struct pfioc_natlook {
+	struct pf_addr	 saddr;
+	struct pf_addr	 daddr;
+	struct pf_addr	 rsaddr;
+	struct pf_addr	 rdaddr;
+	u_int16_t	 sport;
+	u_int16_t	 dport;
+	u_int16_t	 rsport;
+	u_int16_t	 rdport;
+	u_int8_t	 af;
+	u_int8_t	 proto;
+	u_int8_t	 direction;
+};
+
+struct pfioc_binat {
+	u_int32_t	 ticket;
+	u_int32_t	 nr;
+	struct pf_binat	 binat;
+};
+
+struct pfioc_changebinat {
+	u_int32_t	action;
+	struct pf_binat	oldbinat;
+	struct pf_binat	newbinat;
+};
+
+struct pfioc_rdr {
+	u_int32_t	 ticket;
+	u_int32_t	 nr;
+	struct pf_rdr	 rdr;
+};
+
+struct pfioc_changerdr {
+	u_int32_t	 action;
+	struct pf_rdr	 oldrdr;
+	struct pf_rdr	 newrdr;
+};
+
+struct pfioc_state {
+	u_int32_t	 nr;
+	struct pf_state	 state;
+};
+
+struct pfioc_state_kill {
+	/* XXX returns the number of states killed in psk_af */
+	int			psk_af;
+	int			psk_proto;
+	struct pf_rule_addr	psk_src;
+	struct pf_rule_addr	psk_dst;
+};
+
+struct pfioc_states {
+	int	ps_len;
+	union {
+		caddr_t psu_buf;
+		struct pf_state *psu_states;
+	} ps_u;
+#define ps_buf		ps_u.psu_buf
+#define ps_states	ps_u.psu_states
+};
+
+struct pfioc_if {
+	char		 ifname[IFNAMSIZ];
+};
+
+struct pfioc_tm {
+	int		 timeout;
+	int		 seconds;
+};
+
+struct pfioc_limit {
+	int		 index;
+	unsigned	 limit;
+};
+
+/*
+ * ioctl operations
+ */
+
+#define DIOCSTART	_IO  ('D',  1)
+#define DIOCSTOP	_IO  ('D',  2)
+#define DIOCBEGINRULES	_IOWR('D',  3, u_int32_t)
+#define DIOCADDRULE	_IOWR('D',  4, struct pfioc_rule)
+#define DIOCCOMMITRULES	_IOWR('D',  5, u_int32_t)
+#define DIOCGETRULES	_IOWR('D',  6, struct pfioc_rule)
+#define DIOCGETRULE	_IOWR('D',  7, struct pfioc_rule)
+#define DIOCBEGINNATS	_IOWR('D',  8, u_int32_t)
+#define DIOCADDNAT	_IOWR('D',  9, struct pfioc_nat)
+#define DIOCCOMMITNATS	_IOWR('D', 10, u_int32_t)
+#define DIOCGETNATS	_IOWR('D', 11, struct pfioc_nat)
+#define DIOCGETNAT	_IOWR('D', 12, struct pfioc_nat)
+#define DIOCBEGINRDRS	_IOWR('D', 13, u_int32_t)
+#define DIOCADDRDR	_IOWR('D', 14, struct pfioc_rdr)
+#define DIOCCOMMITRDRS	_IOWR('D', 15, u_int32_t)
+#define DIOCGETRDRS	_IOWR('D', 16, struct pfioc_rdr)
+#define DIOCGETRDR	_IOWR('D', 17, struct pfioc_rdr)
+#define DIOCCLRSTATES	_IO  ('D', 18)
+#define DIOCGETSTATE	_IOWR('D', 19, struct pfioc_state)
+#define DIOCSETSTATUSIF _IOWR('D', 20, struct pfioc_if)
+#define DIOCGETSTATUS	_IOWR('D', 21, struct pf_status)
+#define DIOCCLRSTATUS	_IO  ('D', 22)
+#define DIOCNATLOOK	_IOWR('D', 23, struct pfioc_natlook)
+#define DIOCSETDEBUG	_IOWR('D', 24, u_int32_t)
+#define DIOCGETSTATES	_IOWR('D', 25, struct pfioc_states)
+#define DIOCCHANGERULE	_IOWR('D', 26, struct pfioc_changerule)
+#define DIOCCHANGENAT	_IOWR('D', 27, struct pfioc_changenat)
+#define DIOCCHANGERDR	_IOWR('D', 28, struct pfioc_changerdr)
+#define DIOCSETTIMEOUT	_IOWR('D', 29, struct pfioc_tm)
+#define DIOCGETTIMEOUT	_IOWR('D', 30, struct pfioc_tm)
+#define DIOCBEGINBINATS	_IOWR('D', 31, u_int32_t)
+#define DIOCADDBINAT	_IOWR('D', 32, struct pfioc_binat)
+#define DIOCCOMMITBINATS _IOWR('D', 33, u_int32_t)
+#define DIOCGETBINATS	_IOWR('D', 34, struct pfioc_binat)
+#define DIOCGETBINAT	_IOWR('D', 35, struct pfioc_binat)
+#define DIOCCHANGEBINAT	_IOWR('D', 36, struct pfioc_changebinat)
+#define DIOCADDSTATE	_IOWR('D', 37, struct pfioc_state)
+#define DIOCCLRRULECTRS	_IO  ('D', 38)
+#define DIOCGETLIMIT	_IOWR('D', 39, struct pfioc_limit)
+#define DIOCSETLIMIT	_IOWR('D', 40, struct pfioc_limit)
+#define DIOCKILLSTATES	_IOWR('D', 41, struct pfioc_state_kill)
+
+
+#ifdef _KERNEL
+RB_HEAD(pf_state_tree, pf_tree_node);
+RB_PROTOTYPE(pf_state_tree, pf_tree_node, entry, pf_state_compare);
+extern struct pf_state_tree tree_lan_ext, tree_ext_gwy;
+
+extern struct pf_rulequeue		 pf_rules[2];
+TAILQ_HEAD(pf_natqueue, pf_nat);
+extern struct pf_natqueue		 pf_nats[2];
+TAILQ_HEAD(pf_binatqueue, pf_binat);
+extern struct pf_binatqueue		 pf_binats[2];
+TAILQ_HEAD(pf_rdrqueue, pf_rdr);
+extern struct pf_rdrqueue		 pf_rdrs[2];
+
+extern u_int32_t		 ticket_rules_active;
+extern u_int32_t		 ticket_rules_inactive;
+extern u_int32_t		 ticket_nats_active;
+extern u_int32_t		 ticket_nats_inactive;
+extern u_int32_t		 ticket_binats_active;
+extern u_int32_t		 ticket_binats_inactive;
+extern u_int32_t		 ticket_rdrs_active;
+extern u_int32_t		 ticket_rdrs_inactive;
+extern struct pf_rulequeue	*pf_rules_active;
+extern struct pf_rulequeue	*pf_rules_inactive;
+extern struct pf_natqueue	*pf_nats_active;
+extern struct pf_natqueue	*pf_nats_inactive;
+extern struct pf_binatqueue	*pf_binats_active;
+extern struct pf_binatqueue	*pf_binats_inactive;
+extern struct pf_rdrqueue	*pf_rdrs_active;
+extern struct pf_rdrqueue	*pf_rdrs_inactive;
+extern void			 pf_dynaddr_remove(struct pf_addr_wrap *);
+extern int			 pf_dynaddr_setup(struct pf_addr_wrap *,
+				    u_int8_t);
+extern void			 pf_calc_skip_steps(struct pf_rulequeue *);
+extern void			 pf_dynaddr_copyout(struct pf_addr_wrap *);
+extern void			 pf_purge_timeout(void *);
+extern int			 pftm_interval;
+extern int			 pf_compare_rules(struct pf_rule *,
+				    struct pf_rule *);
+extern int			 pf_compare_nats(struct pf_nat *,
+				    struct pf_nat *);
+extern int			 pf_compare_binats(struct pf_binat *,
+				    struct pf_binat *);
+extern int			 pf_compare_rdrs(struct pf_rdr *,
+				    struct pf_rdr *);
+extern void			 pf_purge_expired_states(void);
+extern int			 pf_insert_state(struct pf_state *);
+struct pf_state			*pf_find_state(struct pf_state_tree *,
+				    struct pf_tree_node *);
+extern struct ifnet		*status_ifp;
+extern int			*pftm_timeouts[PFTM_MAX];
+extern void			 pf_addrcpy(struct pf_addr *, struct pf_addr *,
+				    u_int8_t);
+
+#ifdef INET
+extern	int	pf_test(int, struct ifnet *, struct mbuf **);
+#endif /* INET */
+
+#ifdef INET6
+extern	int	pf_test6(int, struct ifnet *, struct mbuf **);
+#endif /* INET6 */
+
+extern int	pflog_packet(struct ifnet *, struct mbuf *, int, u_short, u_short,
+		    struct pf_rule *);
+
+int	pf_match_addr(u_int8_t, struct pf_addr *, struct pf_addr *,
+	    struct pf_addr *, int);
+int	pf_match(u_int8_t, u_int16_t, u_int16_t, u_int16_t);
+int	pf_match_port(u_int8_t, u_int16_t, u_int16_t, u_int16_t);
+int	pf_match_uid(u_int8_t, uid_t, uid_t, uid_t);
+int	pf_match_gid(u_int8_t, gid_t, gid_t, gid_t);
+
+void	pf_normalize_init(void);
+int	pf_normalize_ip(struct mbuf **, int, struct ifnet *, u_short *);
+void	pf_purge_expired_fragments(void);
+int	pf_routable(struct pf_addr *addr, int af);
+
+extern struct pf_status pf_status; 
+extern pool_t           pf_frent_pl, pf_frag_pl;
+struct pf_pool_limit {
+	void		*pp;
+	unsigned	 limit;
+};
+extern struct pf_pool_limit pf_pool_limits[PF_LIMIT_MAX];
+
+#endif /* _KERNEL */
+
+#endif /* _NET_PFVAR_H_ */
